name: 3x-ui VPN Service Management

on:
  push:
    branches: [main]
    paths-ignore:
      - "**.md"
      - ".gitignore"
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      workflow_type:
        description: Workflow to run
        required: true
        default: deploy
        type: choice
        options:
          - setup
          - deploy
          - manage_secrets
      environment:
        description: Environment to target
        required: true
        default: production
        type: choice
        options:
          - production
          - staging

# Define default permissions for GitHub token
permissions:
  contents: read
  actions: read

jobs:
  # Determine which workflow to run
  select_workflow:
    runs-on: ubuntu-latest
    outputs:
      run_setup: ${{ steps.set_vars.outputs.run_setup }}
      run_deploy: ${{ steps.set_vars.outputs.run_deploy }}
      environment: ${{ steps.set_vars.outputs.environment }}
    steps:
      - name: üîç Set workflow variables
        id: set_vars
        run: |
          # Default is to run deploy on push
          RUN_SETUP="false"
          RUN_DEPLOY="false"
          ENVIRONMENT="production"
          
          # Push event runs deploy only on main branch
          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/main" ]]; then
            RUN_DEPLOY="true"
          fi
          
          # Pull request events don't trigger deployments
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            RUN_DEPLOY="false"
          fi
          
          # Workflow dispatch uses specified options
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
            
            if [[ "${{ github.event.inputs.workflow_type }}" == "setup" ]]; then
              RUN_SETUP="true"
            elif [[ "${{ github.event.inputs.workflow_type }}" == "deploy" ]]; then
              RUN_DEPLOY="true"
            fi
          fi
          
          echo "run_setup=${RUN_SETUP}" >> $GITHUB_OUTPUT
          echo "run_deploy=${RUN_DEPLOY}" >> $GITHUB_OUTPUT
          echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT

  # Testing job - runs on all pushes and PRs
  test:
    name: üß™ Test Configuration
    runs-on: ubuntu-latest
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        
      - name: üß∞ Set up Docker
        uses: docker/setup-buildx-action@v3
        
      - name: üß™ Validate Docker Compose
        run: |
          echo "Validating Docker Compose file syntax..."
          
          # Check if docker-compose file exists
          if [ ! -f docker-compose.yml ]; then
            echo "::error::docker-compose.yml not found!"
            exit 1
          fi
          
          # Basic validation of YAML syntax
          cat docker-compose.yml | python -c "import sys, yaml; yaml.safe_load(sys.stdin)" && echo "‚úÖ Valid YAML" || (echo "‚ùå Invalid YAML" && exit 1)
          
          # Check if required services are defined
          grep -q "3x-ui:" docker-compose.yml && echo "‚úÖ 3x-ui service found" || (echo "‚ùå 3x-ui service not found" && exit 1)
      
      - name: üîí Validate secure ports configuration
        run: |
          echo "Validating secure ports configuration..."
          
          # Check for HTTPS port mapping (port 443)
          grep -q "443:443" docker-compose.yml && echo "‚úÖ HTTPS port (443) configured correctly" || (echo "‚ö†Ô∏è HTTPS port (443) might not be configured" && exit 1)
          
          # Check for VPN panel port mapping (port 2053)
          grep -q "2053:2053" docker-compose.yml && echo "‚úÖ VPN Panel port (2053) configured correctly" || (echo "‚ö†Ô∏è VPN Panel port (2053) might not be configured" && exit 1)
      
      - name: üß∞ Test Docker image
        run: |
          echo "Testing Docker image pull..."
          docker pull mhsanaei/3x-ui:latest
          echo "‚úÖ Docker image is available and can be pulled"
          
          # Verify the image has the expected entrypoint/command
          docker inspect mhsanaei/3x-ui:latest --format='{{.Config.Entrypoint}}'
          docker inspect mhsanaei/3x-ui:latest --format='{{.Config.Cmd}}'
          
      - name: üß∞ Static security analysis
        run: |
          # Example using docker scan (if available) or other static analysis tools
          echo "Performing basic static security analysis..."
          
          # Check for any exposed sensitive ports
          if grep -q "54321:54321" docker-compose.yml; then
            echo "‚ö†Ô∏è Admin panel port 54321 is exposed publicly. Consider using reverse proxy with authentication."
          fi
          
          # Check for any hardcoded credentials (simple check)
          if grep -q "password\|secret\|token\|key" docker-compose.yml; then
            echo "‚ö†Ô∏è Potential hardcoded credentials detected in docker-compose.yml"
          else
            echo "‚úÖ No obvious hardcoded credentials detected"
          fi

  # Initial VPS setup workflow
  setup:
    name: üöÄ Initial Server Setup
    needs: [select_workflow, test]
    if: needs.select_workflow.outputs.run_setup == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.select_workflow.outputs.environment }}
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
      
      - name: üîë Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      
      - name: üîê Add host key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
      
      - name: üõ†Ô∏è Server setup
        id: server_setup
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            # Create deployment directory structure
            echo "Creating deployment directory: ${{ secrets.DEPLOY_PATH }}"
            mkdir -p ${{ secrets.DEPLOY_PATH }}
            
            # Create subdirectories
            echo "Creating subdirectories..."
            mkdir -p ${{ secrets.DEPLOY_PATH }}/cert
            mkdir -p ${{ secrets.DEPLOY_PATH }}/logs
            mkdir -p ${{ secrets.DEPLOY_PATH }}/workflow_logs
            
            # Set proper permissions
            echo "Setting permissions..."
            chmod 755 ${{ secrets.DEPLOY_PATH }}
            chmod 700 ${{ secrets.DEPLOY_PATH }}/cert
            
            # Check if Docker is installed
            if ! command -v docker &> /dev/null; then
              echo "Docker not found, installing..."
              curl -fsSL https://get.docker.com -o get-docker.sh
              sh get-docker.sh
            else
              echo "Docker is already installed"
            fi
            
            # Check if Docker Compose is installed
            if ! command -v docker-compose &> /dev/null; then
              echo "Docker Compose not found, installing..."
              apt-get update
              apt-get install -y docker-compose
            else
              echo "Docker Compose is already installed"
            fi
            
            # Set up logrotate for logs
            echo "Setting up log rotation..."
            cat > /tmp/x-ui-logrotate << 'EOL'
            ${{ secrets.DEPLOY_PATH }}/logs/*.log {
                daily
                missingok
                rotate 7
                compress
                delaycompress
                notifempty
                create
            }
            EOL
            sudo mv /tmp/x-ui-logrotate /etc/logrotate.d/x-ui
            
            # Create SSL certificate directory for Let's Encrypt
            mkdir -p ${{ secrets.DEPLOY_PATH }}/cert/letsencrypt
            
            # Log the setup process
            TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
            echo "Server setup completed at ${TIMESTAMP}" > "${{ secrets.DEPLOY_PATH }}/workflow_logs/setup_${TIMESTAMP}.log"
            
            echo "Server setup completed successfully!"
      
      - name: ‚úÖ Verify setup
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            echo "Verifying directory structure..."
            ls -la ${{ secrets.DEPLOY_PATH }}
            
            echo "Verifying Docker installation..."
            docker --version
            docker-compose --version
            
            echo "Setup verification completed!"
  
  # Pre-deployment validation job
  validate:
    name: üîç Pre-deployment Validation
    needs: [select_workflow, test]
    if: needs.select_workflow.outputs.run_deploy == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.select_workflow.outputs.environment }}
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        
      - name: üåê Verify domain configuration
        run: |
          echo "Verifying domain configuration: ${{ secrets.VPN_DOMAIN || 'service.foodshare.club' }}"
          DOMAIN="${{ secrets.VPN_DOMAIN || 'service.foodshare.club' }}"
          
          # Check if the domain resolves
          echo "Checking if domain resolves..."
          nslookup ${DOMAIN} || echo "Warning: Domain may not be properly configured yet"
          
          # Check SSL cert status with timeout in case it's not available
          echo "Checking SSL certificate status..."
          timeout 10s openssl s_client -connect ${DOMAIN}:443 -servername ${DOMAIN} </dev/null 2>/dev/null | openssl x509 -noout -dates || echo "SSL Certificate is not properly configured or not accessible yet"
      
      - name: üß∞ Validate Docker Compose for deployment
        run: |
          # Check if docker-compose file exists
          if [ ! -f docker-compose.yml ]; then
            echo "::error::docker-compose.yml not found!"
            exit 1
          fi
          
          # Basic validation of YAML syntax
          cat docker-compose.yml | python -c "import sys, yaml; yaml.safe_load(sys.stdin)" && echo "‚úÖ Valid YAML" || (echo "‚ùå Invalid YAML" && exit 1)
          
          # Check if required services are defined
          grep -q "3x-ui:" docker-compose.yml && echo "‚úÖ 3x-ui service found" || (echo "‚ùå 3x-ui service not found" && exit 1)
  
  # Deploy SSL certificates with Let's Encrypt (if needed)
  setup_ssl:
    name: üîí Setup SSL Certificate
    needs: [validate, select_workflow]
    runs-on: ubuntu-latest
    environment: ${{ needs.select_workflow.outputs.environment }}
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
      
      - name: üîë Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      
      - name: üîê Add host key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
      
      - name: üîí Generate SSL Certificate
        id: ssl_setup
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            cd ${{ secrets.DEPLOY_PATH }}
            
            # Set domain name
            DOMAIN="${{ secrets.VPN_DOMAIN || 'service.foodshare.club' }}"
            ADMIN_EMAIL="${{ secrets.ADMIN_EMAIL || 'admin@example.com' }}"
            
            # Check if certbot is installed
            if ! command -v certbot &> /dev/null; then
              echo "Certbot not found, installing..."
              apt-get update
              apt-get install -y certbot
            fi
            
            # First stop any running container that might use port 80/443
            docker-compose down || true
            
            # Generate certificate if not already exists
            if [ ! -f "${{ secrets.DEPLOY_PATH }}/cert/fullchain.pem" ]; then
              echo "Generating SSL certificate for ${DOMAIN}..."
              certbot certonly --standalone --preferred-challenges http --agree-tos -n -d ${DOMAIN} -m ${ADMIN_EMAIL} \
                --cert-path=${{ secrets.DEPLOY_PATH }}/cert/cert.pem \
                --fullchain-path=${{ secrets.DEPLOY_PATH }}/cert/fullchain.pem \
                --chain-path=${{ secrets.DEPLOY_PATH }}/cert/chain.pem \
                --key-path=${{ secrets.DEPLOY_PATH }}/cert/privkey.pem \
                --config-dir=${{ secrets.DEPLOY_PATH }}/cert/letsencrypt \
                --work-dir=${{ secrets.DEPLOY_PATH }}/cert/letsencrypt \
                --logs-dir=${{ secrets.DEPLOY_PATH }}/logs/letsencrypt
            else
              echo "SSL certificate already exists, checking expiration..."
              # Check certificate expiration (might need to renew if close to expiration)
              CERT_EXPIRY=$(openssl x509 -enddate -noout -in "${{ secrets.DEPLOY_PATH }}/cert/fullchain.pem" | cut -d= -f2)
              echo "Certificate expires on: ${CERT_EXPIRY}"
              
              # Optional: Add logic to renew if expiring soon
            fi
            
            # Set proper permissions
            chmod 600 ${{ secrets.DEPLOY_PATH }}/cert/*.pem
            
            echo "SSL certificate setup completed successfully!"

  # Deployment workflow
  deploy:
    name: üö¢ Deploy 3x-ui
    needs: [validate, setup_ssl, select_workflow]
    if: always() && needs.validate.result == 'success' && needs.setup_ssl.result == 'success'
    runs-on: ubuntu-latest
    environment: ${{ needs.select_workflow.outputs.environment }}
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
      
      - name: üîë Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      
      - name: üîê Add host key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
      
      - name: üîó Test SSH connection to VPS
        run: |
          echo "Testing SSH connection to ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}..."
          ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "echo '‚úÖ SSH connection successful'" || (echo '‚ùå SSH connection failed' && exit 1)
      
      - name: üì• Pull changes on server
        id: pull_changes
        run: |
          echo "Pulling latest changes on server..."
          ssh -i ${{ secrets.SSH_PRIVATE_KEY }} -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "cd ${{ secrets.DEPLOY_PATH }} && git pull origin main"
      
      - name: üöÄ Deploy VPN service
        id: deploy
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            cd ${{ secrets.DEPLOY_PATH }}
            
            # Set domain name
            DOMAIN="${{ secrets.VPN_DOMAIN || 'service.foodshare.club' }}"
            
            # Log deployment start
            TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
            DEPLOY_LOG="${{ secrets.DEPLOY_PATH }}/workflow_logs/deploy_${TIMESTAMP}.log"
            
            echo "Deployment started at $(date)" >> $DEPLOY_LOG
            echo "Git commit: ${{ github.sha }}" >> $DEPLOY_LOG
            echo "Domain: ${DOMAIN}" >> $DEPLOY_LOG
            
            # Create directories if they don't exist
            mkdir -p cert logs workflow_logs
            
            # Modify config to use domain name if different from YAML
            echo "Updating Docker configuration for domain: ${DOMAIN}" >> $DEPLOY_LOG
            
            # Create/update environment file for Docker Compose
            cat > .env << EOL
            VPN_DOMAIN=${DOMAIN}
            ADMIN_EMAIL=${{ secrets.ADMIN_EMAIL || 'admin@example.com' }}
            EOL
            
            # Stop running container
            echo "Stopping any running containers" >> $DEPLOY_LOG
            docker-compose down >> $DEPLOY_LOG 2>&1 || true
            
            # Pull latest image
            echo "Pulling latest image" >> $DEPLOY_LOG
            docker-compose pull >> $DEPLOY_LOG 2>&1
            
            # Start container
            echo "Starting container" >> $DEPLOY_LOG
            docker-compose up -d >> $DEPLOY_LOG 2>&1
            
            # Save container status
            echo "Container status:" >> $DEPLOY_LOG
            docker-compose ps >> $DEPLOY_LOG 2>&1
            
            # Check initial logs
            echo "Initial container logs:" >> $DEPLOY_LOG
            docker-compose logs --tail=20 >> $DEPLOY_LOG 2>&1
            
            echo "Deployment process completed at $(date)" >> $DEPLOY_LOG
            
            # Create a symlink to the latest deployment log
            ln -sf $DEPLOY_LOG "${{ secrets.DEPLOY_PATH }}/workflow_logs/latest_deploy.log"
  
  # Verification job
  verify:
    name: ‚úÖ Verify Deployment
    needs: [deploy, select_workflow]
    runs-on: ubuntu-latest
    environment: ${{ needs.select_workflow.outputs.environment }}
    
    steps:
      - name: üîë Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      
      - name: üîê Add host key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
      
      - name: üîç Check deployment status
        id: check_status
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            cd ${{ secrets.DEPLOY_PATH }}
            
            # Set domain name
            DOMAIN="${{ secrets.VPN_DOMAIN || 'service.foodshare.club' }}"
            
            # Create verification log
            TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
            VERIFY_LOG="${{ secrets.DEPLOY_PATH }}/workflow_logs/verify_${TIMESTAMP}.log"
            
            echo "Verification started at $(date)" >> $VERIFY_LOG
            echo "Domain: ${DOMAIN}" >> $VERIFY_LOG
            
            # Wait for service to stabilize
            echo "Waiting for service to stabilize..." >> $VERIFY_LOG
            sleep 30
            
            # Check if container is running
            echo "Container status:" >> $VERIFY_LOG
            docker-compose ps >> $VERIFY_LOG 2>&1
            
            # Check if container is healthy
            echo "Container health check:" >> $VERIFY_LOG
            CONTAINER_STATUS=$(docker inspect --format='{{.State.Health.Status}}' 3x-ui 2>/dev/null || echo "Container not found")
            echo "Health status: $CONTAINER_STATUS" >> $VERIFY_LOG
            
            # Get detailed logs for troubleshooting if needed
            echo "Container logs:" >> $VERIFY_LOG
            docker-compose logs --tail=50 >> $VERIFY_LOG 2>&1
            
            # Check if services are accessible
            echo "Checking if admin panel is accessible:" >> $VERIFY_LOG
            curl -s -o /dev/null -w "%{http_code}" http://localhost:54321/login >> $VERIFY_LOG 2>&1 || echo "Failed to connect to admin panel" >> $VERIFY_LOG
            
            # Check if domain is accessible
            echo "Checking if domain ${DOMAIN} is accessible:" >> $VERIFY_LOG
            curl -s -o /dev/null -w "%{http_code}" -k https://${DOMAIN} >> $VERIFY_LOG 2>&1 || echo "Failed to connect to domain" >> $VERIFY_LOG
            
            # Check if VPN panel URL is accessible
            echo "Checking if VPN panel URL is accessible:" >> $VERIFY_LOG
            curl -s -o /dev/null -w "%{http_code}" -k https://${DOMAIN}:2053/BXv8SI7gBe/ >> $VERIFY_LOG 2>&1 || echo "Failed to connect to VPN panel" >> $VERIFY_LOG
            
            # Output verification summary
            echo "Verification completed at $(date)" >> $VERIFY_LOG
            
            # Create a symlink to the latest verification log
            ln -sf $VERIFY_LOG "${{ secrets.DEPLOY_PATH }}/workflow_logs/latest_verify.log"
            
            # Evaluate if deployment was successful
            if [[ "$CONTAINER_STATUS" = "healthy" ]]; then
              echo "‚úÖ Deployment verification successful! Container is healthy."
              exit 0
            else
              echo "‚ùå Deployment verification failed. Container status: $CONTAINER_STATUS"
              echo "See logs for details: $VERIFY_LOG"
              exit 1
            fi
      
      - name: üì• Download logs
        if: always()
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          source: "${{ secrets.DEPLOY_PATH }}/workflow_logs/latest_*.log"
          target: "./workflow_logs"
          strip_components: 2
      
      - name: üì¶ Archive logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-logs
          path: ./workflow_logs/
          retention-days: 7

  # Secret Management job (manual trigger only)
  manage_secrets:
    name: üîê Manage Repository Secrets
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.workflow_type == 'manage_secrets'
    runs-on: ubuntu-latest
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
      
      - name: üîë Set up GitHub CLI
        run: |
          # Install GitHub CLI if needed (already available in GitHub Actions)
          if ! command -v gh &> /dev/null; then
            echo "Installing GitHub CLI..."
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
            sudo apt update
            sudo apt install gh
          fi
      
      - name: üìã List current secrets
        id: list_secrets
        run: |
          echo "Current repository secrets:"
          gh api repos/${{ github.repository }}/actions/secrets --silent | jq -r '.secrets[].name' 2>/dev/null || echo "No secrets found or failed to retrieve"
          
          echo "Required secrets for this workflow:"
          echo "- SSH_PRIVATE_KEY: SSH private key for accessing the server"
          echo "- SSH_KNOWN_HOSTS: SSH known hosts file contents"
          echo "- SERVER_HOST: Server hostname or IP address"
          echo "- SERVER_USER: Username for SSH connection"
          echo "- DEPLOY_PATH: Path to deploy the application on the server"
          echo "- VPN_DOMAIN: Domain name for the VPN service (default: service.foodshare.club)"
          echo "- ADMIN_EMAIL: Email address for Let's Encrypt certificate (for SSL notifications)" 