permissions:
  contents: read

name: 3x-ui VPN Service Management

on:
  workflow_dispatch:
  push:
    branches:
      - main
    paths-ignore:
      - README.md
      - .gitignore
      - logs/**
      - workflow_logs/**
  schedule:
    - cron: 0 2 * * *  # Run daily at 2 AM UTC for backups

jobs:
  debug_info:
    name: 🐛 Debug Workflow Info
    runs-on: ubuntu-latest
    steps:
      - name: Display Trigger Info
        env:
          GH_EVENT_NAME: ${{ github.event_name }}
          GH_REF_NAME: ${{ github.ref_name }}
          GH_BASE_REF: ${{ github.base_ref }}
          GH_REF_TYPE: ${{ github.ref_type }}
          GH_REPOSITORY: ${{ github.repository }}
          GH_RUN_ID: ${{ github.run_id }}
        run: |
          echo "Workflow triggered by: $GH_EVENT_NAME"
          echo "Ref name: $GH_REF_NAME"
          echo "Base ref: $GH_BASE_REF"
          echo "Ref type: $GH_REF_TYPE"
          echo "Repository: $GH_REPOSITORY"
          echo "Run ID: $GH_RUN_ID"
          echo "Auto-deploy mode: enabled"

  cert_fix:
    name: 🚑 Emergency Certificate Fix
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' && contains(github.event.inputs, 'run_cert_fix_only') && github.event.inputs.run_cert_fix_only == 'true' }}
    steps:
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      - name: Add to known hosts
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
      - name: Fix SSL Certificates
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            set -ex  # Enable verbose logging and exit on errors
            
            # Define variables
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            DOMAIN="${{ secrets.VPN_DOMAIN }}"
            CERT_DIR="$DEPLOY_PATH/cert/$DOMAIN"
            
            echo "🔍 Checking current container status..."
            cd "$DEPLOY_PATH"
            docker-compose ps
            
            echo "📁 Creating certificate directory..."
            mkdir -p "$CERT_DIR"
            
            echo "🔑 Creating self-signed certificates..."
            openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
              -keyout "$CERT_DIR/privkey.pem" \
              -out "$CERT_DIR/fullchain.pem" \
              -subj "/CN=$DOMAIN/O=3x-ui/C=US" \
              -addext "subjectAltName=DNS:$DOMAIN"
            
            echo "🔒 Setting permissions..."
            chmod 644 "$CERT_DIR/fullchain.pem"
            chmod 600 "$CERT_DIR/privkey.pem"
            
            echo "🔄 Restarting 3x-ui container..."
            docker-compose restart 3x-ui
            
            echo "✅ Certificate fix complete!"
            echo "📋 Container status after fix:"
            docker-compose ps
            
            echo "📋 Certificate details:"
            openssl x509 -noout -text -in "$CERT_DIR/fullchain.pem" | grep -E "Subject:|Issuer:|Not Before:|Not After :|DNS:"
            
            echo "📋 Container logs (last 10 lines):"
            sleep 5  # Give the container time to start
            docker-compose logs --tail=10 3x-ui
          EOL
      - name: Add to workflow summary
        run: |
          echo "# 🚑 Certificate Emergency Fix" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Emergency certificate fix was applied to ensure the service has valid SSL certificates." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "For production use, consider running the full workflow to acquire proper Let's Encrypt certificates." >> $GITHUB_STEP_SUMMARY

  validate:
    name: 🔍 Validate Configuration
    runs-on: ubuntu-latest
    needs: debug_info
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Validate Docker Compose
        run: |
          if [ ! -f docker-compose.yml ]; then
            echo "ERROR: docker-compose.yml not found!"
            exit 1
          fi
          cat docker-compose.yml | python3 -c "import sys, yaml; yaml.safe_load(sys.stdin)" && echo "✅ Valid YAML"
          grep -q "3x-ui:" docker-compose.yml && echo "✅ 3x-ui service found"
          grep -q "54321:54321" docker-compose.yml && echo "✅ Admin panel port (54321) configured"

  setup:
    name: 🚀 Setup Server
    needs: validate
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      - name: Add to known hosts
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
      - name: Check SSH connectivity
        run: |
          ssh -o BatchMode=yes -o ConnectTimeout=10 ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            echo '✅ SSH connection successful'
          EOL
      - name: Initialize Git repository on server
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            set -ex  # Enable verbose logging and exit on error
            
            # Define deploy path
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            REPO_URL="https://github.com/${{ github.repository }}.git"
            
            echo "Current working directory: $(pwd)"
            echo "Checking if $DEPLOY_PATH exists..."
            
            # Check if the directory exists
            if [ -d "$DEPLOY_PATH" ]; then
              echo "Directory $DEPLOY_PATH exists"
              cd "$DEPLOY_PATH"
              
              # Check if it's a git repository
              if [ -d ".git" ]; then
                echo "Git repository exists in $DEPLOY_PATH"
                
                # Reset repository to ensure it works
                git status || {
                  echo "Git status failed, recreating repository"
                  cd ..
                  rm -rf "$(basename "$DEPLOY_PATH")"
                  git clone "$REPO_URL" "$(basename "$DEPLOY_PATH")"
                  cd "$DEPLOY_PATH"
                }
              else
                echo "Directory exists but not a git repository"
                # Backup existing files
                BACKUP_DIR="/tmp/3x-ui-backup-$(date +%s)"
                mkdir -p "$BACKUP_DIR"
                find . -type f -name ".env*" -exec cp --parents {} "$BACKUP_DIR/" \;
                find . -type f -path "./db/*" -exec cp --parents {} "$BACKUP_DIR/" \;
                find . -type f -path "./logs/*" -exec cp --parents {} "$BACKUP_DIR/" \;
                
                # Convert to git repository
                cd ..
                mv "$(basename "$DEPLOY_PATH")" "${DEPLOY_PATH}_old"
                git clone "$REPO_URL" "$(basename "$DEPLOY_PATH")"
                cd "$DEPLOY_PATH"
                
                # Restore backed up files
                if [ -d "$BACKUP_DIR" ]; then
                  cp -r "$BACKUP_DIR"/* ./ 2>/dev/null || true
                fi
              fi
            else
              echo "Directory $DEPLOY_PATH does not exist, creating and cloning repository"
              # Create parent directory if needed
              mkdir -p "$(dirname "$DEPLOY_PATH")"
              
              # Clone repository
              git clone "$REPO_URL" "$DEPLOY_PATH"
              cd "$DEPLOY_PATH"
            fi
            
            # Verify repository setup
            echo "Current directory: $(pwd)"
            echo "Repository content:"
            ls -la
            echo "Git status:"
            git status
            echo "Latest commits:"
            git log -n 3 --oneline || echo "No commits yet"
          EOL
      - name: Install Docker if not installed
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
          if ! command -v docker &> /dev/null; then
            echo "Installing Docker..."
            curl -fsSL https://get.docker.com -o get-docker.sh
            sudo sh get-docker.sh
            sudo usermod -aG docker $USER
          else
            echo "Docker already installed."
          fi
          if ! command -v docker-compose &> /dev/null; then
            echo "Installing Docker Compose..."
            sudo curl -L "https://github.com/docker/compose/releases/download/v2.15.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
          else
            echo "Docker Compose already installed."
          fi
          EOL

  deploy:
    name: 🚢 Deploy VPN Service
    needs: [setup]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      - name: Add to known hosts
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
      - name: Deploy from Git
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            set -ex  # Enable verbose logging and exit on error
            
            # Define variables
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            REPO_URL="https://github.com/${{ github.repository }}.git"
            DEPLOY_BRANCH="main"
            REPO_ROOT=$(dirname "$DEPLOY_PATH")
            REPO_DIR=$(basename "$DEPLOY_PATH")
            
            # Go to parent directory
            cd "$REPO_ROOT"
            
            # Forcibly recreate the repository to ensure we have the latest clean state
            echo "🔄 Ensuring clean repository state with latest code"
            if [ -d "$REPO_DIR" ]; then
              # Backup important data first
              echo "📦 Backing up important data"
              BACKUP_DIR="/tmp/3x-ui-backup-$(date +%s)"
              mkdir -p "$BACKUP_DIR"
              
              # Enter repo dir for backup
              cd "$REPO_DIR"
              
              # Backup essential files
              if [ -f ".env" ]; then
                cp .env "$BACKUP_DIR/"
              fi
              
              if [ -d "db" ]; then
                mkdir -p "$BACKUP_DIR/db"
                cp -r db/* "$BACKUP_DIR/db/" 2>/dev/null || true
              fi
              
              if [ -d "logs" ]; then
                mkdir -p "$BACKUP_DIR/logs"
                cp -r logs/* "$BACKUP_DIR/logs/" 2>/dev/null || true
              fi
              
              # Return to parent directory
              cd "$REPO_ROOT"
              
              # Remove old repository
              echo "🗑️ Removing old repository"
              rm -rf "$REPO_DIR"
            fi
            
            # Clone fresh repository
            echo "🔄 Cloning fresh repository from $REPO_URL"
            git clone -b "$DEPLOY_BRANCH" "$REPO_URL" "$REPO_DIR"
            
            # Enter repository
            cd "$REPO_DIR"
            
            # Restore data from backup
            if [ -d "$BACKUP_DIR" ]; then
              echo "📦 Restoring data from backup"
              
              # Restore .env
              if [ -f "$BACKUP_DIR/.env" ]; then
                cp "$BACKUP_DIR/.env" .env
                echo "✅ Restored .env file"
              fi
              
              # Restore database
              if [ -d "$BACKUP_DIR/db" ]; then
                mkdir -p db
                cp -r "$BACKUP_DIR/db/"* db/ 2>/dev/null || true
                echo "✅ Restored database files"
              fi
              
              # Restore logs
              if [ -d "$BACKUP_DIR/logs" ]; then
                mkdir -p logs
                cp -r "$BACKUP_DIR/logs/"* logs/ 2>/dev/null || true
                echo "✅ Restored log files"
              fi
            fi
            
            # Create default .env if it doesn't exist
            if [ ! -f ".env" ]; then
              if [ -f ".env.example" ]; then
                cp .env.example .env
                echo "📄 Created .env file from template"
              else
                touch .env
                echo "📄 Created empty .env file"
              fi
            fi
            
            # Ensure required directories exist
            echo "📁 Ensuring required directories exist"
            mkdir -p db cert logs cert/service.foodshare.club docs
            
            # Ensure db/x-ui.db exists and is a file
            if [ -d "db/x-ui.db" ]; then
              echo "⚠️ db/x-ui.db is a directory, fixing..."
              rm -rf db/x-ui.db
              touch db/x-ui.db
              echo "✅ Fixed db/x-ui.db"
            elif [ ! -f "db/x-ui.db" ]; then
              echo "📄 Creating db/x-ui.db placeholder"
              touch db/x-ui.db
            fi
            
            # Set up Docker networks
            echo "🌐 Setting up Docker networks"
            docker network create web 2>/dev/null || true
            docker network create no-zero-trust-cloudflared 2>/dev/null || true
            
            # Deploy containers
            echo "🚀 Deploying containers"
            docker-compose pull
            docker-compose down
            docker-compose up -d
            
            echo "✅ Deployment completed!"
            echo "🔎 Container status:"
            docker-compose ps
            
            # Check if Caddy config exists and display information
            if [ -f "docs/caddy-config.md" ]; then
              echo "⚠️ IMPORTANT: Update your Caddy configuration with:"
              echo "📁 $(pwd)/docs/caddy-config.md"
            fi
            
            # Verify deployed version
            echo "📋 Deployed version information:"
            git log -n 1 --pretty=format:"Commit: %h%nAuthor: %an%nDate: %ad%nMessage: %s"
          EOL
      - name: Verify deployment
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            set -ex  # Enable verbose logging and exit on error
            
            # Define deploy path
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            
            echo "Verifying deployment in $DEPLOY_PATH"
            cd "$DEPLOY_PATH" || {
              echo "ERROR: Unable to cd to $DEPLOY_PATH"
              exit 1
            }
            
            echo "Directory structure:"
            find . -type d -maxdepth 2 | sort
            
            echo "Critical files:"
            ls -la docker-compose.yml .env* db/ 2>/dev/null || echo "Some files may be missing"
            
            echo "Container status:"
            docker-compose ps
            
            echo "Running containers:"
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            
            echo "Container logs (last 10 lines):"
            docker-compose logs --tail=10
            
            echo "Checking if 3x-ui container is running:"
            if docker ps | grep -q '3x-ui'; then
              echo "✅ 3x-ui container is running"
            else
              echo "❌ 3x-ui container is NOT running!"
              echo "Container details:"
              docker ps -a | grep 3x-ui || echo "No container found"
              echo "Container logs:"
              docker-compose logs 3x-ui
              exit 1
            fi
            
            echo "✅ Deployment verification completed successfully"
          EOL

  verify:
    name: ✅ Verify Deployment
    needs: deploy
    runs-on: ubuntu-latest
    steps:
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      - name: Add to known hosts
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
      - name: Verify deployment
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            set -ex  # Enable verbose logging and exit on error
            
            # Define deploy path
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            
            echo "Verifying deployment in $DEPLOY_PATH"
            cd "$DEPLOY_PATH" || {
              echo "ERROR: Unable to cd to $DEPLOY_PATH"
              exit 1
            }
            
            echo "Directory structure:"
            find . -type d -maxdepth 2 | sort
            
            echo "Critical files:"
            ls -la docker-compose.yml .env* db/ 2>/dev/null || echo "Some files may be missing"
            
            echo "Container status:"
            docker-compose ps
            
            echo "Running containers:"
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            
            echo "Container logs (last 10 lines):"
            docker-compose logs --tail=10
            
            echo "Checking if 3x-ui container is running:"
            if docker ps | grep -q '3x-ui'; then
              echo "✅ 3x-ui container is running"
            else
              echo "❌ 3x-ui container is NOT running!"
              echo "Container details:"
              docker ps -a | grep 3x-ui || echo "No container found"
              echo "Container logs:"
              docker-compose logs 3x-ui
              exit 1
            fi
            
            echo "✅ Deployment verification completed successfully"
          EOL

  logs:
    name: 📊 Collect Logs
    needs: [deploy, verify]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      - name: Add to known hosts
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
      - name: Ensure logs directory is not empty
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} '
            set -e
            cd ${{ secrets.DEPLOY_PATH }}
            mkdir -p logs
            sudo chown $USER:$USER logs
            sudo chmod 777 logs
            if [ -z "$(ls -A logs)" ]; then
              echo "No logs found, creating dummy.log"
              sudo touch logs/dummy.log
              sudo chmod 666 logs/dummy.log
              echo "No logs available." | sudo tee logs/dummy.log
            fi
            echo "Contents of logs directory after ensuring dummy.log:"
            ls -l logs
            if [ -z "$(ls -A logs)" ]; then
              echo "ERROR: logs directory is still empty after attempting to create dummy.log"
              exit 1
            else
              echo "Logs directory is ready for SCP."
            fi
          '
      - name: Copy local dummy.log to server if needed
        run: |
          echo "No logs available." > dummy.log
          scp -o StrictHostKeyChecking=no dummy.log ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:${{ secrets.DEPLOY_PATH }}/logs/dummy.log
      - name: "Debug: List logs directory on server before SCP"
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} '
            cd ${{ secrets.DEPLOY_PATH }}
            echo "Listing logs directory before SCP:"
            ls -l logs
          '
      - name: Create local workflow_logs directory
        run: |
          mkdir -p workflow_logs
          echo "No logs available. Created by workflow." > workflow_logs/dummy.log
          echo "Created local workflow_logs directory with dummy file for artifact upload"
      - name: Download logs from server
        run: |
          # Create a directory for logs
          mkdir -p downloaded_logs
          # Try to download logs using scp, but don't fail if it doesn't work
          scp -o StrictHostKeyChecking=no -r ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:${{ secrets.DEPLOY_PATH }}/logs/* downloaded_logs/ || true
          # Check if we got any logs, if not create a dummy file
          if [ -z "$(ls -A downloaded_logs)" ]; then
            echo "No logs were downloaded, creating a dummy log file"
            echo "No logs were available on the server at the time of collection." > downloaded_logs/empty_logs.txt
          fi
          # Copy all downloaded logs to the workflow_logs directory
          cp -r downloaded_logs/* workflow_logs/ || true
          # List what we have
          echo "Contents of workflow_logs directory:"
          ls -la workflow_logs/
      - name: Archive logs
        uses: actions/upload-artifact@v4
        with:
          name: deployment-logs
          path: workflow_logs/
          retention-days: 7

  summary:
    name: 🎉 Deployment Summary
    needs: [debug_info, validate, setup, deploy, verify, logs, cert_fix]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Generate Summary
        run: |
          echo "# 3x-ui VPN Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ !env.SHOULD_DEPLOY == 'true' }}" == "true" ]]; then
            echo "✅ **Certificate Fix**: Emergency fix applied" >> $GITHUB_STEP_SUMMARY
          else
            echo "✅ **Debug Info**: See debug_info job" >> $GITHUB_STEP_SUMMARY
            echo "✅ **Configuration Validation**: See validate job" >> $GITHUB_STEP_SUMMARY
            echo "✅ **SSH Setup**: See setup job" >> $GITHUB_STEP_SUMMARY
            echo "✅ **SSL Certificates**: See certificates job" >> $GITHUB_STEP_SUMMARY
            echo "✅ **Deployment**: See deploy job" >> $GITHUB_STEP_SUMMARY
            echo "✅ **Verification**: See verify job" >> $GITHUB_STEP_SUMMARY
            echo "✅ **Logs**: See logs job" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Access Information" >> $GITHUB_STEP_SUMMARY
          echo "🔗 **Admin Panel**: https://${{ secrets.VPN_DOMAIN }}/BXv8SI7gBe/" >> $GITHUB_STEP_SUMMARY
      - name: Output Result
        run: |
          if [[ "${{ !env.SHOULD_DEPLOY == 'true' }}" == "true" ]]; then
            echo "✅ 3x-ui VPN certificate fix completed."
          else
            echo "✅ 3x-ui VPN deployment workflow completed."
          fi 