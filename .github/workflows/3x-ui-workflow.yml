permissions:
  contents: read

name: 3x-ui VPN Service Management

on:
  workflow_dispatch:
  push:
    branches:
      - main
    paths-ignore:
      - README.md
      - .gitignore
      - logs/**
      - workflow_logs/**
  schedule:
    - cron: 0 2 * * *  # Run daily at 2 AM UTC for backups

# Add concurrency to cancel queued workflows
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  debug_info:
    name: üêõ Debug Workflow Info
    runs-on: ubuntu-latest
    steps:
      - name: Display Trigger Info
        env:
          GH_EVENT_NAME: ${{ github.event_name }}
          GH_REF_NAME: ${{ github.ref_name }}
          GH_BASE_REF: ${{ github.base_ref }}
          GH_REF_TYPE: ${{ github.ref_type }}
          GH_REPOSITORY: ${{ github.repository }}
          GH_RUN_ID: ${{ github.run_id }}
        run: |
          echo "Workflow triggered by: $GH_EVENT_NAME"
          echo "Ref name: $GH_REF_NAME"
          echo "Base ref: $GH_BASE_REF"
          echo "Ref type: $GH_REF_TYPE"
          echo "Repository: $GH_REPOSITORY"
          echo "Run ID: $GH_RUN_ID"
          echo "Auto-deploy mode: enabled"

  cert_fix:
    name: üöë Emergency Certificate Fix
    runs-on: ubuntu-latest
    if: false  # Disabled by default, use separate workflow for cert fixes
    steps:
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      - name: Add to known hosts
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
      - name: Fix SSL Certificates
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            set -ex  # Enable verbose logging and exit on errors

            # Define variables
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            DOMAIN="${{ secrets.VPN_DOMAIN }}"
            CERT_DIR="$DEPLOY_PATH/cert/$DOMAIN"

            echo "üîç Checking current container status..."
            cd "$DEPLOY_PATH"
            docker-compose ps

            echo "üìÅ Creating certificate directory..."
            mkdir -p "$CERT_DIR"

            echo "üîë Creating self-signed certificates..."
            openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
              -keyout "$CERT_DIR/privkey.pem" \
              -out "$CERT_DIR/fullchain.pem" \
              -subj "/CN=$DOMAIN/O=3x-ui/C=US" \
              -addext "subjectAltName=DNS:$DOMAIN,DNS:$DOMAIN:2053"

            echo "üîí Setting permissions..."
            chmod 644 "$CERT_DIR/fullchain.pem"
            chmod 600 "$CERT_DIR/privkey.pem"

            echo "üîÑ Restarting 3x-ui container..."
            docker-compose restart 3x-ui

            echo "‚úÖ Certificate fix complete!"
            echo "üìã Container status after fix:"
            docker-compose ps

            echo "üìã Certificate details:"
            openssl x509 -noout -text -in "$CERT_DIR/fullchain.pem" | grep -E "Subject:|Issuer:|Not Before:|Not After :|DNS:"

            echo "üìã Container logs (last 10 lines):"
            sleep 5  # Give the container time to start
            docker-compose logs --tail=10 3x-ui
          EOL
      - name: Add to workflow summary
        run: |
          echo "# üöë Certificate Emergency Fix" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Emergency certificate fix was applied to ensure the service has valid SSL certificates." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "For production use, consider running the full workflow to acquire proper Let's Encrypt certificates." >> $GITHUB_STEP_SUMMARY

  validate:
    name: üîç Validate Configuration
    runs-on: ubuntu-latest
    needs: debug_info
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Validate Docker Compose
        run: |
          if [ ! -f docker-compose.yml ]; then
            echo "ERROR: docker-compose.yml not found!"
            exit 1
          fi
          cat docker-compose.yml | python3 -c "import sys, yaml; yaml.safe_load(sys.stdin)" && echo "‚úÖ Valid YAML"
          grep -q "3x-ui:" docker-compose.yml && echo "‚úÖ 3x-ui service found"
          grep -q "\\${HTTPS_PORT}:2053" docker-compose.yml && echo "‚úÖ Admin panel port (${HTTPS_PORT}:2053) configured"

  setup:
    name: üöÄ Setup Server
    needs: validate
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      - name: Add to known hosts
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
      - name: Check SSH connectivity
        run: |
          ssh -o BatchMode=yes -o ConnectTimeout=10 ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            echo '‚úÖ SSH connection successful'
          EOL
      - name: Fix directory permissions
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            set -ex
            
            # Define variables
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            
            # Go to directory if it exists
            if [ -d "$DEPLOY_PATH" ]; then
              cd "$DEPLOY_PATH"
              
              # Fix caddy_data permissions with sudo if available
              if [ -d "caddy_data" ]; then
                echo "üîß Fixing caddy_data permissions..."
                sudo find caddy_data -type d -exec chmod 755 {} \; 2>/dev/null || true
                sudo find caddy_data -type f -exec chmod 644 {} \; 2>/dev/null || true
                sudo chown -R $USER:$USER caddy_data 2>/dev/null || true
              fi
              
              # Fix logs directory
              if [ -d "logs" ]; then
                echo "üîß Fixing logs directory permissions..."
                sudo chown -R $USER:$USER logs 2>/dev/null || true
                sudo chmod -R 777 logs 2>/dev/null || true
              fi
              
              # Fix Git repository permissions - critical for fetch/pull operations
              if [ -d ".git" ]; then
                echo "üîß Fixing Git repository permissions..."
                sudo chown -R $USER:$USER .git 2>/dev/null || true
                sudo chmod -R 755 .git/objects 2>/dev/null || true
                sudo chmod -R 755 .git/refs 2>/dev/null || true
                sudo chmod 755 .git/HEAD .git/config 2>/dev/null || true
              fi
              
              # Fix other common problematic directories
              echo "üîß Fixing cert directory permissions..."
              sudo mkdir -p cert 2>/dev/null || true
              sudo chown -R $USER:$USER cert 2>/dev/null || true
              sudo chmod -R 755 cert 2>/dev/null || true
              
              echo "üîß Fixing db directory permissions..."
              sudo mkdir -p db 2>/dev/null || true
              sudo chown -R $USER:$USER db 2>/dev/null || true
              sudo chmod -R 755 db 2>/dev/null || true
              
              echo "‚úÖ Directory permissions fixed"
            else
              echo "‚ö†Ô∏è Deploy path $DEPLOY_PATH does not exist yet, skipping permission fixes"
            fi
          EOL
      - name: Fix Git Repository
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            set -ex  # Enable verbose logging and exit on error

            # Define variables
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            REPO_URL="https://github.com/${{ github.repository }}.git"

            # Colors for better output readability
            RED='\033[0;31m'
            GREEN='\033[0;32m'
            YELLOW='\033[1;33m'
            BLUE='\033[0;34m'
            NC='\033[0m' # No Color

            echo -e "${BLUE}==== Fixing Git Repository ====${NC}"

            # Ensure directory exists
            if [ ! -d "$DEPLOY_PATH" ]; then
              echo -e "${YELLOW}Directory $DEPLOY_PATH doesn't exist. Creating...${NC}"
              mkdir -p "$DEPLOY_PATH"
            fi

            # Go to directory
            cd "$DEPLOY_PATH" || {
              echo -e "${RED}Failed to cd to $DEPLOY_PATH${NC}"
              exit 1
            }

            # Check if .git directory exists
            if [ -d ".git" ]; then
              echo -e "${GREEN}Git repository exists. Fixing permissions...${NC}"
              
              # Use the fix_git_permissions.sh script if it exists
              if [ -f "scripts/fix_git_permissions.sh" ]; then
                echo -e "${YELLOW}Running Git permissions fix script...${NC}"
                chmod +x scripts/fix_git_permissions.sh
                ./scripts/fix_git_permissions.sh || {
                  echo -e "${RED}Permission fix script failed. Trying manual fix...${NC}"
                  sudo chown -R $USER:$USER .git 2>/dev/null || true
                  sudo chmod -R 755 .git/objects 2>/dev/null || true
                  sudo chmod -R 755 .git/refs 2>/dev/null || true
                  sudo chmod 755 .git/HEAD .git/config 2>/dev/null || true
                }
              else
                echo -e "${YELLOW}Fix script not found. Applying manual fixes...${NC}"
                sudo chown -R $USER:$USER .git 2>/dev/null || true
                sudo chmod -R 755 .git/objects 2>/dev/null || true
                sudo chmod -R 755 .git/refs 2>/dev/null || true
                sudo chmod 755 .git/HEAD .git/config 2>/dev/null || true
              fi

              # Check for uncommitted changes and forcibly remove them
              echo -e "${YELLOW}Checking for uncommitted changes...${NC}"
              if git status --porcelain | grep -q .; then
                echo -e "${YELLOW}Local changes detected. Forcibly discarding them...${NC}"
                git reset --hard HEAD || {
                  echo -e "${RED}Failed to reset. Using force...${NC}"
                  git update-ref -d HEAD
                  git checkout -f HEAD
                }
                git clean -fdx
                echo -e "${GREEN}Local changes discarded.${NC}"
              else
                echo -e "${GREEN}No local changes detected.${NC}"
              fi
            else
              echo -e "${YELLOW}No Git repository found. Initializing...${NC}"
              git init
              git remote add origin "$REPO_URL"
            fi
          EOL
      - name: Force Clone Repository
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            set -ex  # Enable verbose logging and exit on errors
            
            # Define variables
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            REPO_URL="https://github.com/${{ github.repository }}.git"
            
            # Colors for output
            RED='\033[0;31m'
            GREEN='\033[0;32m'
            YELLOW='\033[1;33m'
            BLUE='\033[0;34m'
            NC='\033[0m' # No Color
            
            echo -e "${BLUE}==== Force Cloning Repository ====${NC}"
            
            # Create timestamp for backup directory
            TIMESTAMP=$(date +%s)
            BACKUP_DIR="/tmp/3x-ui-backup-$TIMESTAMP"
            mkdir -p "$BACKUP_DIR"
            
            # Check if deploy path exists
            if [ -d "$DEPLOY_PATH" ]; then
              cd "$DEPLOY_PATH"
              
              # Backup essential data before replacing the repository
              echo -e "${YELLOW}Creating backup of essential data...${NC}"
              if [ -d "db" ]; then
                cp -r db "$BACKUP_DIR/" || sudo cp -r db "$BACKUP_DIR/"
                echo -e "${GREEN}Database backup created${NC}"
              else
                echo -e "${YELLOW}No database directory found to backup${NC}"
              fi
              
              if [ -d "cert" ]; then
                cp -r cert "$BACKUP_DIR/" || sudo cp -r cert "$BACKUP_DIR/"
                echo -e "${GREEN}Certificate backup created${NC}"
              else
                echo -e "${YELLOW}No certificate directory found to backup${NC}"
              fi
              
              if [ -d "logs" ]; then
                cp -r logs "$BACKUP_DIR/" || sudo cp -r logs "$BACKUP_DIR/"
                echo -e "${GREEN}Logs backup created${NC}"
              else
                echo -e "${YELLOW}No logs directory found to backup${NC}"
              fi
              
              if [ -f ".env" ]; then
                cp .env "$BACKUP_DIR/" || sudo cp .env "$BACKUP_DIR/"
                echo -e "${GREEN}Environment file backed up${NC}"
              else
                echo -e "${YELLOW}No .env file found to backup${NC}"
              fi
              
              # Move up to parent directory
              cd ..
              
              # Save the directory name
              DIR_NAME=$(basename "$DEPLOY_PATH")
              
              # Remove or rename the old directory
              echo -e "${YELLOW}Removing old repository directory...${NC}"
              if ! rm -rf "$DIR_NAME"; then
                echo -e "${YELLOW}Using sudo to remove directory...${NC}"
                sudo rm -rf "$DIR_NAME" || {
                  echo -e "${YELLOW}Failed to remove directory, renaming instead...${NC}"
                  mv "$DIR_NAME" "${DIR_NAME}.old" || sudo mv "$DIR_NAME" "${DIR_NAME}.old"
                }
              fi
            else
              # Parent directory exists
              cd "$(dirname "$DEPLOY_PATH")"
            fi
            
            # Clone fresh repository
            echo -e "${YELLOW}Cloning fresh repository...${NC}"
            if ! git clone "$REPO_URL" "$(basename "$DEPLOY_PATH")"; then
              echo -e "${YELLOW}Standard clone failed, trying with depth=1...${NC}"
              git clone --depth=1 "$REPO_URL" "$(basename "$DEPLOY_PATH")"
            fi
            
            # Change to the new repository directory
            cd "$DEPLOY_PATH"
            
            # Restore backup data
            echo -e "${YELLOW}Restoring backed up data...${NC}"
            
            # Restore database
            if [ -d "$BACKUP_DIR/db" ]; then
              echo -e "${YELLOW}Restoring database...${NC}"
              mkdir -p db
              cp -r "$BACKUP_DIR/db/"* db/ 2>/dev/null || true
              echo -e "${GREEN}Database restored${NC}"
            fi
            
            # Restore certificates
            if [ -d "$BACKUP_DIR/cert" ]; then
              echo -e "${YELLOW}Restoring certificates...${NC}"
              mkdir -p cert
              cp -r "$BACKUP_DIR/cert/"* cert/ 2>/dev/null || true
              echo -e "${GREEN}Certificates restored${NC}"
            fi
            
            # Restore logs
            if [ -d "$BACKUP_DIR/logs" ]; then
              echo -e "${YELLOW}Restoring logs...${NC}"
              mkdir -p logs
              cp -r "$BACKUP_DIR/logs/"* logs/ 2>/dev/null || true
              echo -e "${GREEN}Logs restored${NC}"
            fi
            
            # Restore .env file
            if [ -f "$BACKUP_DIR/.env" ]; then
              echo -e "${YELLOW}Restoring .env file...${NC}"
              cp "$BACKUP_DIR/.env" .env
              echo -e "${GREEN}Environment file restored${NC}"
            fi
            
            # Make all scripts executable
            echo -e "${YELLOW}Making scripts executable...${NC}"
            find ./scripts -name "*.sh" -exec chmod +x {} \; 2>/dev/null || true
            
            echo -e "${GREEN}Repository successfully recreated and data restored!${NC}"
            echo -e "${YELLOW}Repository status:${NC}"
            git status
          EOL
      - name: Setup SSL Certificates
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            set -ex  # Enable verbose logging and exit on error

            # Define variables
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            DOMAIN="${{ secrets.VPN_DOMAIN }}"
            CERT_DIR="$DEPLOY_PATH/cert/$DOMAIN"

            # Colors for outpu
            RED='\033[0;31m'
            GREEN='\033[0;32m'
            YELLOW='\033[1;33m'
            BLUE='\033[0;34m'
            NC='\033[0m' # No Color

            echo -e "${BLUE}==== Setting up SSL Certificates ====${NC}"

            # Check if we're already in the deploy path, if not change to i
            if [ "$(pwd)" != "$DEPLOY_PATH" ]; then
              cd "$DEPLOY_PATH" || {
                echo -e "${RED}Failed to cd to $DEPLOY_PATH${NC}"
                exit 1
              }
            fi

            # Create certificate directory if it doesn't exis
            if [ ! -d "$CERT_DIR" ]; then
              echo -e "${YELLOW}Creating certificate directory: $CERT_DIR${NC}"
              mkdir -p "$CERT_DIR"
            else
              echo -e "${GREEN}Certificate directory exists.${NC}"
            fi

            # Check if certificate files exis
            if [ ! -f "$CERT_DIR/fullchain.pem" ] || [ ! -f "$CERT_DIR/privkey.pem" ]; then
              echo -e "${YELLOW}Certificates missing. Generating self-signed certificates...${NC}"
              
              # Generate self-signed certificate
              openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
                -keyout "$CERT_DIR/privkey.pem" \
                -out "$CERT_DIR/fullchain.pem" \
                -subj "/CN=$DOMAIN/O=3x-ui/C=US" \
                -addext "subjectAltName=DNS:$DOMAIN,DNS:$DOMAIN:2053" || {
                  echo -e "${RED}Failed to generate certificates. Trying alternate method...${NC}"
                  
                  # Fallback method - simpler OpenSSL command
                  openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
                    -keyout "$CERT_DIR/privkey.pem" \
                    -out "$CERT_DIR/fullchain.pem" \
                    -subj "/CN=$DOMAIN" \
                    -addext "subjectAltName=DNS:$DOMAIN,DNS:$DOMAIN:2053" || {
                      echo -e "${RED}Both certificate generation methods failed.${NC}"
                      exit 1
                    }
                }

              echo -e "${GREEN}Self-signed certificates generated successfully.${NC}"
            else
              echo -e "${GREEN}Certificates already exist.${NC}"

              # Check certificate expiration
              echo -e "${YELLOW}Checking certificate expiration...${NC}"
              END_DATE=$(openssl x509 -enddate -noout -in "$CERT_DIR/fullchain.pem" | cut -d= -f2)
              END_EPOCH=$(date -d "$END_DATE" +%s 2>/dev/null || date -j -f "%b %d %H:%M:%S %Y %Z" "$END_DATE" +%s 2>/dev/null)
              NOW_EPOCH=$(date +%s)
              DAYS_LEFT=$(( ($END_EPOCH - $NOW_EPOCH) / 86400 ))

              if [ $? -eq 0 ] && [ $DAYS_LEFT -lt 30 ]; then
                echo -e "${YELLOW}Certificate expires in $DAYS_LEFT days. Renewing...${NC}"

                # Backup existing certificates
                cp "$CERT_DIR/fullchain.pem" "$CERT_DIR/fullchain.pem.bak"
                cp "$CERT_DIR/privkey.pem" "$CERT_DIR/privkey.pem.bak"

                # Generate new self-signed certificate
                openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
                  -keyout "$CERT_DIR/privkey.pem" \
                  -out "$CERT_DIR/fullchain.pem" \
                  -subj "/CN=$DOMAIN/O=3x-ui/C=US" \
                  -addext "subjectAltName=DNS:$DOMAIN,DNS:$DOMAIN:2053" || {
                    echo -e "${RED}Failed to renew certificates. Restoring backup...${NC}"
                    cp "$CERT_DIR/fullchain.pem.bak" "$CERT_DIR/fullchain.pem"
                    cp "$CERT_DIR/privkey.pem.bak" "$CERT_DIR/privkey.pem"
                  }

                echo -e "${GREEN}Certificate renewed successfully.${NC}"
              else
                echo -e "${GREEN}Certificate is still valid.${NC}"
              fi
            fi

            # Make a symbolic link to the service.foodshare.club directory in the right place
            echo -e "${YELLOW}Ensuring certificates are accessible to 3x-ui container...${NC}"

            # Create directory structure firs
            mkdir -p "$DEPLOY_PATH/cert"
            mkdir -p "$DEPLOY_PATH/cert/$DOMAIN"

            # Check if certificates exist in expected location
            if [ -f "$CERT_DIR/fullchain.pem" ] && [ -f "$CERT_DIR/privkey.pem" ]; then
              echo -e "${GREEN}Certificates found in domain directory: $CERT_DIR${NC}"

              # Copy certificates to the root level as well
              cp -f "$CERT_DIR/fullchain.pem" "$DEPLOY_PATH/cert/fullchain.pem"
              cp -f "$CERT_DIR/privkey.pem" "$DEPLOY_PATH/cert/privkey.pem"
              echo -e "${GREEN}Certificates copied to cert root directory${NC}"
            else
              echo -e "${RED}Certificates not found in domain directory.${NC}"

              # Check if they exist in the roo
              if [ -f "$DEPLOY_PATH/cert/fullchain.pem" ] && [ -f "$DEPLOY_PATH/cert/privkey.pem" ]; then
                echo -e "${YELLOW}Certificates found in root directory, copying to domain directory...${NC}"
                cp -f "$DEPLOY_PATH/cert/fullchain.pem" "$CERT_DIR/fullchain.pem"
                cp -f "$DEPLOY_PATH/cert/privkey.pem" "$CERT_DIR/privkey.pem"
                echo -e "${GREEN}Certificates copied from root to domain directory${NC}"
              else
                echo -e "${RED}No certificates found. Generating new ones...${NC}"

                # Generate self-signed certificates in both locations
                openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
                  -keyout "$CERT_DIR/privkey.pem" \
                  -out "$CERT_DIR/fullchain.pem" \
                  -subj "/CN=$DOMAIN" \
                  -addext "subjectAltName=DNS:$DOMAIN,DNS:$DOMAIN:2053"

                # Also copy to root level
                cp -f "$CERT_DIR/fullchain.pem" "$DEPLOY_PATH/cert/fullchain.pem"
                cp -f "$CERT_DIR/privkey.pem" "$DEPLOY_PATH/cert/privkey.pem"
                echo -e "${GREEN}New certificates generated and copied to both locations${NC}"
              fi
            fi

            # Set proper permissions for both locations
            chmod 644 "$CERT_DIR/fullchain.pem" "$DEPLOY_PATH/cert/fullchain.pem"
            chmod 600 "$CERT_DIR/privkey.pem" "$DEPLOY_PATH/cert/privkey.pem"
            echo -e "${GREEN}Certificate permissions set correctly${NC}"
          EOL
      - name: Install Docker if not installed
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
          if ! command -v docker &> /dev/null; then
            echo "Installing Docker..."
            curl -fsSL https://get.docker.com -o get-docker.sh
            sudo sh get-docker.sh
            sudo usermod -aG docker $USER
          else
            echo "Docker already installed."
          fi
          if ! command -v docker-compose &> /dev/null; then
            echo "Installing Docker Compose..."
            sudo curl -L "https://github.com/docker/compose/releases/download/v2.15.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
          else
            echo "Docker Compose already installed."
          fi
          EOL

  deploy:
    name: üö¢ Deploy VPN Service
    needs: [setup]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      - name: Add to known hosts
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
      - name: Deploy from Gi
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            set -ex  # Enable verbose logging and exit on error

            # Define variables
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            REPO_URL="https://github.com/${{ github.repository }}.git"
            DEPLOY_BRANCH="main"
            REPO_ROOT=$(dirname "$DEPLOY_PATH")
            REPO_DIR=$(basename "$DEPLOY_PATH")

            # Colors for outpu
            RED='\033[0;31m'
            GREEN='\033[0;32m'
            YELLOW='\033[1;33m'
            NC='\033[0m' # No Color

            echo -e "${GREEN}==== Deploying 3x-ui VPN Service ====${NC}"

            # Check current state
            echo -e "${YELLOW}Checking repository at $DEPLOY_PATH${NC}"
            if [ -d "$DEPLOY_PATH" ]; then
              cd "$DEPLOY_PATH"

              # Check for uncommitted changes first and forcibly remove them
              if [ -d ".git" ]; then
                echo -e "${YELLOW}Checking for uncommitted changes...${NC}"
                if git status --porcelain | grep -q .; then
                  echo -e "${YELLOW}Local changes detected. Forcibly discarding them...${NC}"
                  git reset --hard HEAD
                  git clean -fdx
                  echo -e "${GREEN}Local changes discarded.${NC}"
                else
                  echo -e "${GREEN}No local changes detected.${NC}"
                fi
              fi

              # Count files to see if repository has conten
              FILE_COUNT=$(find . -type f | wc -l)
              if [ "$FILE_COUNT" -lt 5 ]; then
                echo -e "${RED}Repository has minimal files ($FILE_COUNT found). Recreating...${NC}"
                NEEDS_RECREATE=true
              else
                echo -e "${GREEN}Repository has $FILE_COUNT files.${NC}"
                # Check if docker-compose.yml exists
                if [ ! -f "docker-compose.yml" ]; then
                  echo -e "${RED}Missing docker-compose.yml. Recreating repository...${NC}"
                  NEEDS_RECREATE=true
                else
                  echo -e "${GREEN}docker-compose.yml exists.${NC}"
                  NEEDS_RECREATE=false
                fi
              fi
            else
              echo -e "${YELLOW}Repository directory does not exist. Creating...${NC}"
              mkdir -p "$DEPLOY_PATH"
              NEEDS_RECREATE=true
            fi

            # Backup important data firs
            echo -e "${YELLOW}Backing up important data${NC}"
            BACKUP_DIR="/tmp/3x-ui-backup-$(date +%s)"
            mkdir -p "$BACKUP_DIR"

            if [ -d "$DEPLOY_PATH" ]; then
              cd "$DEPLOY_PATH"

              # Backup essential files
              if [ -f ".env" ]; then
                cp .env "$BACKUP_DIR/"
                echo -e "${GREEN}Backed up .env file${NC}"
              fi

              if [ -d "db" ]; then
                mkdir -p "$BACKUP_DIR/db"
                cp -r db/* "$BACKUP_DIR/db/" 2>/dev/null || true
                echo -e "${GREEN}Backed up database files${NC}"
              fi

              if [ -d "logs" ]; then
                mkdir -p "$BACKUP_DIR/logs"
                cp -r logs/* "$BACKUP_DIR/logs/" 2>/dev/null || true
                echo -e "${GREEN}Backed up log files${NC}"
              fi

              if [ -d "cert" ]; then
                mkdir -p "$BACKUP_DIR/cert"
                cp -r cert/* "$BACKUP_DIR/cert/" 2>/dev/null || true
                echo -e "${GREEN}Backed up certificate files${NC}"
              fi
            fi

            # Recreate repository if needed
            if [ "$NEEDS_RECREATE" = true ]; then
              # Go to parent directory
              cd "$REPO_ROOT"

              # Rename old directory if it exists
              if [ -d "$REPO_DIR" ]; then
                TIMESTAMP=$(date +%s)
                mv "$REPO_DIR" "${REPO_DIR}_old_${TIMESTAMP}"
                echo -e "${YELLOW}Renamed old directory to ${REPO_DIR}_old_${TIMESTAMP}${NC}"
              fi

              # Clone fresh repository
              echo -e "${YELLOW}Cloning fresh repository from $REPO_URL${NC}"
              git clone -b "$DEPLOY_BRANCH" "$REPO_URL" "$REPO_DIR"

              # Enter repository
              cd "$REPO_DIR"

              # Verify clone was successful
              if [ ! -f "docker-compose.yml" ]; then
                echo -e "${RED}ERROR: docker-compose.yml not found after cloning. Check repository.${NC}"
                ls -la
                exit 1
              else
                echo -e "${GREEN}Repository cloned successfully with docker-compose.yml present.${NC}"
              fi
            else
              # If we don't need to recreate, just pull latest changes
              cd "$DEPLOY_PATH"
              echo -e "${YELLOW}Discarding any local changes and pulling latest changes...${NC}"
              # Force reset to discard local changes before pulling
              git reset --hard HEAD
              git clean -fdx
              # Pull with force flag to override any local changes
              git fetch origin "$DEPLOY_BRANCH"

              # Try to reset to the origin branch, but if it fails, try a more aggressive approach
              if ! git reset --hard origin/"$DEPLOY_BRANCH"; then
                echo -e "${RED}Failed to reset to origin/$DEPLOY_BRANCH. Trying more aggressive approach...${NC}"

                # Backup important data
                TIMESTAMP=$(date +%s)
                BACKUP_DIR="/tmp/3x-ui-backup-$TIMESTAMP"
                mkdir -p "$BACKUP_DIR"

                # Backup essential data
                if [ -d "db" ]; then
                  cp -r db "$BACKUP_DIR/"
                fi
                if [ -d "cert" ]; then
                  cp -r cert "$BACKUP_DIR/"
                fi
                if [ -d "logs" ]; then
                  cp -r logs "$BACKUP_DIR/"
                fi
                if [ -f ".env" ]; then
                  cp .env "$BACKUP_DIR/"
                fi

                # Remove the git repository
                rm -rf .gi

                # Initialize a new repository
                git init
                git remote add origin "$REPO_URL"
                git fetch origin
                git checkout -b "$DEPLOY_BRANCH" --track "origin/$DEPLOY_BRANCH"

                # Restore the backed up data
                if [ -d "$BACKUP_DIR/db" ]; then
                  cp -r "$BACKUP_DIR/db" .
                fi
                if [ -d "$BACKUP_DIR/cert" ]; then
                  cp -r "$BACKUP_DIR/cert" .
                fi
                if [ -d "$BACKUP_DIR/logs" ]; then
                  cp -r "$BACKUP_DIR/logs" .
                fi
                if [ -f "$BACKUP_DIR/.env" ]; then
                  cp "$BACKUP_DIR/.env" .
                fi

                echo -e "${GREEN}Successfully recreated repository and restored data.${NC}"
              else
                echo -e "${GREEN}Successfully reset to latest changes.${NC}"
              fi
            fi

            # Make sure we're in the repository
            cd "$DEPLOY_PATH"

            # Restore data from backup
            if [ -d "$BACKUP_DIR" ]; then
              echo -e "${YELLOW}Restoring from backup...${NC}"

              # Restore .env
              if [ -f "$BACKUP_DIR/.env" ]; then
                cp "$BACKUP_DIR/.env" .env
                echo -e "${GREEN}Restored .env file${NC}"
              fi

              # Restore database
              if [ -d "$BACKUP_DIR/db" ] && [ "$(ls -A "$BACKUP_DIR/db" 2>/dev/null)" ]; then
                mkdir -p db
                cp -r "$BACKUP_DIR/db/"* db/ 2>/dev/null || true
                echo -e "${GREEN}Restored database files${NC}"
              fi

              # Restore logs
              if [ -d "$BACKUP_DIR/logs" ] && [ "$(ls -A "$BACKUP_DIR/logs" 2>/dev/null)" ]; then
                mkdir -p logs
                cp -r "$BACKUP_DIR/logs/"* logs/ 2>/dev/null || true
                echo -e "${GREEN}Restored log files${NC}"
              fi

              # Restore certificates
              if [ -d "$BACKUP_DIR/cert" ] && [ "$(ls -A "$BACKUP_DIR/cert" 2>/dev/null)" ]; then
                mkdir -p cer
                cp -r "$BACKUP_DIR/cert/"* cert/ 2>/dev/null || true
                echo -e "${GREEN}Restored certificate files${NC}"
              fi
            fi

            # Generate .env file from GitHub secrets
            echo "üìÑ Generating .env file from GitHub secrets"

            # Ensure scripts directory exists and is executable
            mkdir -p scripts

            # Create environment variables to pass to scrip
            export PANEL_PATH="${{ secrets.PANEL_PATH }}"
            export HTTPS_PORT="${{ secrets.HTTPS_PORT }}"
            export VPN_DOMAIN="${{ secrets.VPN_DOMAIN }}"
            export ADMIN_EMAIL="${{ secrets.ADMIN_EMAIL }}"
            export XRAY_VMESS_AEAD_FORCED="${{ secrets.XRAY_VMESS_AEAD_FORCED }}"
            export XUI_USERNAME="${{ secrets.XUI_USERNAME }}"
            export XUI_PASSWORD="${{ secrets.XUI_PASSWORD }}"
            export JWT_SECRET="${{ secrets.JWT_SECRET }}"

            # Run the script to generate .env file
            if [ -f "scripts/generate_env.sh" ]; then
              chmod +x scripts/generate_env.sh
              ./scripts/generate_env.sh
              echo "‚úÖ .env file generated from GitHub secrets"
            else
              echo "‚ö†Ô∏è generate_env.sh script not found, creating basic .env file"

              # Create .env file line by line instead of using heredoc (avoiding YAML parsing issues)
              echo "# 3x-ui VPN Service Configuration" > .env
              echo "# Generated by CI/CD on $(date)" >> .env
              echo "" >> .env
              echo "# Panel Path - The secure path for accessing the admin panel" >> .env
              echo "PANEL_PATH=${{ secrets.PANEL_PATH }}" >> .env
              echo "" >> .env
              echo "# HTTPS Port - Port for accessing the admin interface" >> .env
              echo "HTTPS_PORT=${{ secrets.HTTPS_PORT }}" >> .env
              echo "" >> .env
              echo "# VPN Domain - The domain name for your VPN service" >> .env
              echo "VPN_DOMAIN=${{ secrets.VPN_DOMAIN }}" >> .env
              echo "" >> .env
              echo "# Admin Email - Email address for certificate notifications" >> .env
              echo "ADMIN_EMAIL=${{ secrets.ADMIN_EMAIL }}" >> .env
              echo "" >> .env
              echo "# XRay Configuration" >> .env
              echo "XRAY_VMESS_AEAD_FORCED=${{ secrets.XRAY_VMESS_AEAD_FORCED }}" >> .env
              echo "" >> .env
              echo "# Admin Credentials" >> .env
              echo "XUI_USERNAME=${{ secrets.XUI_USERNAME }}" >> .env
              echo "XUI_PASSWORD=${{ secrets.XUI_PASSWORD }}" >> .env
              echo "" >> .env
              echo "# JWT Secret - Used for authentication" >> .env
              echo "JWT_SECRET=${{ secrets.JWT_SECRET }}" >> .env
              chmod 600 .env
              echo "‚úÖ Basic .env file created with GitHub secrets"
            fi

            # Ensure required directories exis
            echo "üìÅ Ensuring required directories exist"
            mkdir -p db cert logs cert/service.foodshare.club docs

            # Ensure db/x-ui.db exists and is a file
            if [ -d "db/x-ui.db" ]; then
              echo "‚ö†Ô∏è db/x-ui.db is a directory, fixing..."
              rm -rf db/x-ui.db
              touch db/x-ui.db
              echo "‚úÖ Fixed db/x-ui.db"
            elif [ ! -f "db/x-ui.db" ]; then
              echo "üìÑ Creating db/x-ui.db placeholder"
              touch db/x-ui.db
            fi

            # Set up Docker networks
            echo "üåê Setting up Docker networks"

            # Use our new networks and volumes setup script
            chmod +x scripts/create_networks.sh
            ./scripts/create_networks.sh

            # Deploy containers
            echo "üöÄ Deploying containers"
            docker-compose pull
            docker-compose down
            docker-compose up -d

            echo "‚úÖ Deployment completed!"
            echo "üîé Container status:"
            docker-compose ps

            # Check if Caddy config exists and display information
            if [ -f "docs/caddy-config.md" ]; then
              echo "‚ö†Ô∏è IMPORTANT: Update your Caddy configuration with:"
              echo "üìÅ $(pwd)/docs/caddy-config.md"
            fi

            # Verify deployed version
            echo "üìã Deployed version information:"
            git log -n 1 --pretty=format:"Commit: %h%nAuthor: %an%nDate: %ad%nMessage: %s"
          EOL
      - name: Restart Container to Apply Certificate Changes
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            set -ex

            # Define variables
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"

            cd "$DEPLOY_PATH"

            echo "üîÑ Restarting container to apply certificate changes..."

            # Ensure certificate directory exists in both locations
            mkdir -p "$DEPLOY_PATH/cert/service.foodshare.club"

            # Make sure the certificate exists in all required locations
            if [ -f "$DEPLOY_PATH/cert/service.foodshare.club/fullchain.pem" ]; then
              echo "‚úÖ Certificates exist in domain directory"

              # Also create certificates in the root cert directory for fallback
              cp "$DEPLOY_PATH/cert/service.foodshare.club/fullchain.pem" "$DEPLOY_PATH/cert/fullchain.pem"
              cp "$DEPLOY_PATH/cert/service.foodshare.club/privkey.pem" "$DEPLOY_PATH/cert/privkey.pem"

              echo "‚úÖ Copied certificates to root cert directory"
            else
              echo "‚ùå Certificates not found in domain directory!"
            fi

            # Set proper permissions
            chmod 644 "$DEPLOY_PATH/cert/service.foodshare.club/fullchain.pem" "$DEPLOY_PATH/cert/fullchain.pem"
            chmod 600 "$DEPLOY_PATH/cert/service.foodshare.club/privkey.pem" "$DEPLOY_PATH/cert/privkey.pem"

            # Execute our deployment helper scrip
            chmod +x scripts/deploy.sh
            ./scripts/deploy.sh

            # Configure firewall if needed
            if ! docker-compose ps | grep -q "3x-ui.*Up"; then
              echo "‚ö†Ô∏è Container may not be running correctly, checking firewall..."
              sudo chmod +x scripts/configure_firewall.sh
              sudo ./scripts/configure_firewall.sh

              # Try restarting again
              ./scripts/deploy.sh
            fi
          EOL
      - name: Verify deploymen
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            set -ex  # Enable verbose logging and exit on error

            # Define deploy path
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"

            echo "Verifying deployment in $DEPLOY_PATH"
            cd "$DEPLOY_PATH" || {
              echo "ERROR: Unable to cd to $DEPLOY_PATH"
              exit 1
            }

            echo "Directory structure:"
            find . -type d -maxdepth 2 | sort

            echo "Critical files:"
            ls -la docker-compose.yml .env* db/ 2>/dev/null || echo "Some files may be missing"

            echo "Container status:"
            docker-compose ps

            echo "Running containers:"
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

            echo "Container logs (last 10 lines):"
            docker-compose logs --tail=10

            echo "Checking if 3x-ui container is running:"
            if docker ps | grep -q '3x-ui'; then
              echo "‚úÖ 3x-ui container is running"
            else
              echo "‚ùå 3x-ui container is NOT running!"
              echo "Container details:"
              docker ps -a | grep 3x-ui || echo "No container found"
              echo "Container logs:"
              docker-compose logs 3x-ui
              exit 1
            fi

            echo "‚úÖ Deployment verification completed successfully"
          EOL

  verify:
    name: ‚úÖ Verify Deploymen
    needs: deploy
    runs-on: ubuntu-latest
    steps:
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      - name: Add to known hosts
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
      - name: Verify deploymen
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            set -ex  # Enable verbose logging and exit on error

            # Define deploy path
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"

            echo "Verifying deployment in $DEPLOY_PATH"
            cd "$DEPLOY_PATH" || {
              echo "ERROR: Unable to cd to $DEPLOY_PATH"
              exit 1
            }

            echo "Directory structure:"
            find . -type d -maxdepth 2 | sort

            echo "Critical files:"
            ls -la docker-compose.yml .env* db/ 2>/dev/null || echo "Some files may be missing"

            echo "Container status:"
            docker-compose ps

            echo "Running containers:"
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

            echo "Container logs (last 10 lines):"
            docker-compose logs --tail=10

            echo "Checking if 3x-ui container is running:"
            if docker ps | grep -q '3x-ui'; then
              echo "‚úÖ 3x-ui container is running"
            else
              echo "‚ùå 3x-ui container is NOT running!"
              echo "Container details:"
              docker ps -a | grep 3x-ui || echo "No container found"
              echo "Container logs:"
              docker-compose logs 3x-ui
              exit 1
            fi

            echo "‚úÖ Deployment verification completed successfully"
          EOL

  logs:
    name: üìä Collect Logs
    needs: [deploy, verify]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      - name: Add to known hosts
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
      - name: Ensure logs directory is not empty
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} '
            set -e
            cd ${{ secrets.DEPLOY_PATH }}
            mkdir -p logs
            sudo chown $USER:$USER logs
            sudo chmod 777 logs
            if [ -z "$(ls -A logs)" ]; then
              echo "No logs found, creating dummy.log"
              sudo touch logs/dummy.log
              sudo chmod 666 logs/dummy.log
              echo "No logs available." | sudo tee logs/dummy.log
            fi
            echo "Contents of logs directory after ensuring dummy.log:"
            ls -l logs
            if [ -z "$(ls -A logs)" ]; then
              echo "ERROR: logs directory is still empty after attempting to create dummy.log"
              exit 1
            else
              echo "Logs directory is ready for SCP."
            fi
          '
      - name: Copy local dummy.log to server if needed
        run: |
          echo "No logs available." > dummy.log
          scp -o StrictHostKeyChecking=no dummy.log ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:${{ secrets.DEPLOY_PATH }}/logs/dummy.log
      - name: "Debug: List logs directory on server before SCP"
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} '
            cd ${{ secrets.DEPLOY_PATH }}
            echo "Listing logs directory before SCP:"
            ls -l logs
          '
      - name: Create local workflow_logs directory
        run: |
          mkdir -p workflow_logs
          echo "No logs available. Created by workflow." > workflow_logs/dummy.log
          echo "Created local workflow_logs directory with dummy file for artifact upload"
      - name: Download logs from server
        run: |
          # Create a directory for logs
          mkdir -p downloaded_logs
          # Try to download logs using scp, but don't fail if it doesn't work
          scp -o StrictHostKeyChecking=no -r ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:${{ secrets.DEPLOY_PATH }}/logs/* downloaded_logs/ || true
          # Check if we got any logs, if not create a dummy file
          if [ -z "$(ls -A downloaded_logs)" ]; then
            echo "No logs were downloaded, creating a dummy log file"
            echo "No logs were available on the server at the time of collection." > downloaded_logs/empty_logs.tx
          fi
          # Copy all downloaded logs to the workflow_logs directory
          cp -r downloaded_logs/* workflow_logs/ || true
          # List what we have
          echo "Contents of workflow_logs directory:"
          ls -la workflow_logs/
      - name: Archive logs
        uses: actions/upload-artifact@v4
        with:
          name: deployment-logs
          path: workflow_logs/
          retention-days: 7

  summary:
    name: üéâ Deployment Summary
    needs: [debug_info, validate, setup, deploy, verify, logs, cert_fix]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Generate Summary
        run: |
          echo "# 3x-ui VPN Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "‚úÖ **Debug Info**: See debug_info job" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **Configuration Validation**: See validate job" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **SSH Setup**: See setup job" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **Deployment**: See deploy job" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **Verification**: See verify job" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **Logs**: See logs job" >> $GITHUB_STEP_SUMMARY

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Access Information" >> $GITHUB_STEP_SUMMARY
          echo "üîó **Admin Panel**: https://${{ secrets.VPN_DOMAIN }}/BXv8SI7gBe/" >> $GITHUB_STEP_SUMMARY
      - name: Output Resul
        run: |
          echo "‚úÖ 3x-ui VPN deployment workflow completed."