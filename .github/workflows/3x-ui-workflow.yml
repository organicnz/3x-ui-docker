permissions:
  contents: read

name: 3x-ui VPN Service Management

on:
  workflow_dispatch:
    inputs:
      run_cert_fix_only:
        description: 'Run only the certificate fix job'
        type: boolean
        default: false
      environment:
        description: 'Environment to deploy to'
        type: string
        default: 'production'
  push:
    branches:
      - main
    paths-ignore:
      - README.md
      - .gitignore
      - logs/**
      - workflow_logs/**
  schedule:
    - cron: 0 2 * * *  # Run daily at 2 AM UTC for backups

jobs:
  debug_info:
    name: üêõ Debug Workflow Info
    runs-on: ubuntu-latest
    if: ${{ !inputs.run_cert_fix_only }}
    env:
      GH_EVENT_NAME: ${{ github.event_name }}
      GH_REF_NAME: ${{ github.ref_name }}
      GH_HEAD_REF: ${{ github.head_ref }}
      GH_BASE_REF: ${{ github.base_ref }}
      GH_REF_TYPE: ${{ github.ref_type }}
      GH_REPOSITORY: ${{ github.repository }}
    steps:
      - name: Display Trigger Info
        run: |
          echo "Workflow triggered by: $GH_EVENT_NAME"
          echo "Ref name: $GH_REF_NAME"
          echo "Head ref: $GH_HEAD_REF"
          echo "Base ref: $GH_BASE_REF"
          echo "Ref type: $GH_REF_TYPE"
          echo "Repository: $GH_REPOSITORY"

  cert_fix:
    name: üöë Emergency Certificate Fix
    runs-on: ubuntu-latest
    # This job can run either as part of the workflow or on its own
    steps:
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      - name: Add to known hosts
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
      - name: Fix SSL Certificates
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            set -ex  # Enable verbose logging and exit on errors
            
            # Define variables
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            DOMAIN="${{ secrets.VPN_DOMAIN }}"
            CERT_DIR="$DEPLOY_PATH/cert/$DOMAIN"
            
            echo "üîç Checking current container status..."
            cd "$DEPLOY_PATH"
            docker-compose ps
            
            echo "üìÅ Creating certificate directory..."
            mkdir -p "$CERT_DIR"
            
            echo "üîë Creating self-signed certificates..."
            openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
              -keyout "$CERT_DIR/privkey.pem" \
              -out "$CERT_DIR/fullchain.pem" \
              -subj "/CN=$DOMAIN/O=3x-ui/C=US" \
              -addext "subjectAltName=DNS:$DOMAIN"
            
            echo "üîí Setting permissions..."
            chmod 644 "$CERT_DIR/fullchain.pem"
            chmod 600 "$CERT_DIR/privkey.pem"
            
            echo "üîÑ Restarting 3x-ui container..."
            docker-compose restart 3x-ui
            
            echo "‚úÖ Certificate fix complete!"
            echo "üìã Container status after fix:"
            docker-compose ps
            
            echo "üìã Certificate details:"
            openssl x509 -noout -text -in "$CERT_DIR/fullchain.pem" | grep -E "Subject:|Issuer:|Not Before:|Not After :|DNS:"
            
            echo "üìã Container logs (last 10 lines):"
            sleep 5  # Give the container time to start
            docker-compose logs --tail=10 3x-ui
          EOL
      - name: Add to workflow summary
        run: |
          echo "# üöë Certificate Emergency Fix" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Emergency certificate fix was applied to ensure the service has valid SSL certificates." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "For production use, consider running the full workflow to acquire proper Let's Encrypt certificates." >> $GITHUB_STEP_SUMMARY

  validate:
    name: üîç Validate Configuration
    runs-on: ubuntu-latest
    if: ${{ !inputs.run_cert_fix_only }}
    needs: debug_info
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Validate Docker Compose
        run: |
          if [ ! -f docker-compose.yml ]; then
            echo "ERROR: docker-compose.yml not found!"
            exit 1
          fi
          cat docker-compose.yml | python3 -c "import sys, yaml; yaml.safe_load(sys.stdin)" && echo "‚úÖ Valid YAML"
          grep -q "3x-ui:" docker-compose.yml && echo "‚úÖ 3x-ui service found"
          grep -q "54321:54321" docker-compose.yml && echo "‚úÖ Admin panel port (54321) configured"
          grep -q ":443" docker-compose.yml && echo "‚úÖ HTTPS port mapping (:443) configured"

  setup:
    name: üöÄ Setup Server
    needs: validate
    runs-on: ubuntu-latest
    if: ${{ !inputs.run_cert_fix_only }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      - name: Add to known hosts
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
      - name: Check SSH connectivity
        run: |
          ssh -o BatchMode=yes -o ConnectTimeout=10 ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            echo '‚úÖ SSH connection successful'
          EOL
      - name: Initialize Git repository on server
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            set -ex  # Enable verbose logging and exit on error
            
            # Define deploy path
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            REPO_URL="https://github.com/${{ github.repository }}.git"
            
            echo "Current working directory: $(pwd)"
            echo "Checking if $DEPLOY_PATH exists..."
            
            # Check if the directory exists
            if [ -d "$DEPLOY_PATH" ]; then
              echo "Directory $DEPLOY_PATH exists"
              cd "$DEPLOY_PATH"
              
              # Check if it's a git repository
              if [ -d ".git" ]; then
                echo "Git repository exists in $DEPLOY_PATH"
                
                # Reset repository to ensure it works
                git status || {
                  echo "Git status failed, recreating repository"
                  cd ..
                  rm -rf "$(basename "$DEPLOY_PATH")"
                  git clone "$REPO_URL" "$(basename "$DEPLOY_PATH")"
                  cd "$DEPLOY_PATH"
                }
              else
                echo "Directory exists but not a git repository"
                # Backup existing files
                BACKUP_DIR="/tmp/3x-ui-backup-$(date +%s)"
                mkdir -p "$BACKUP_DIR"
                find . -type f -name ".env*" -exec cp --parents {} "$BACKUP_DIR/" \;
                find . -type f -path "./db/*" -exec cp --parents {} "$BACKUP_DIR/" \;
                find . -type f -path "./logs/*" -exec cp --parents {} "$BACKUP_DIR/" \;
                
                # Convert to git repository
                cd ..
                mv "$(basename "$DEPLOY_PATH")" "${DEPLOY_PATH}_old"
                git clone "$REPO_URL" "$(basename "$DEPLOY_PATH")"
                cd "$DEPLOY_PATH"
                
                # Restore backed up files
                if [ -d "$BACKUP_DIR" ]; then
                  cp -r "$BACKUP_DIR"/* ./ 2>/dev/null || true
                fi
              fi
            else
              echo "Directory $DEPLOY_PATH does not exist, creating and cloning repository"
              # Create parent directory if needed
              mkdir -p "$(dirname "$DEPLOY_PATH")"
              
              # Clone repository
              git clone "$REPO_URL" "$DEPLOY_PATH"
              cd "$DEPLOY_PATH"
            fi
            
            # Verify repository setup
            echo "Current directory: $(pwd)"
            echo "Repository content:"
            ls -la
            echo "Git status:"
            git status
            echo "Latest commits:"
            git log -n 3 --oneline || echo "No commits yet"
          EOL
      - name: Install Docker if not installed
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
          if ! command -v docker &> /dev/null; then
            echo "Installing Docker..."
            curl -fsSL https://get.docker.com -o get-docker.sh
            sudo sh get-docker.sh
            sudo usermod -aG docker $USER
          else
            echo "Docker already installed."
          fi
          if ! command -v docker-compose &> /dev/null; then
            echo "Installing Docker Compose..."
            sudo curl -L "https://github.com/docker/compose/releases/download/v2.15.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
          else
            echo "Docker Compose already installed."
          fi
          EOL

  certificates:
    name: üîí Setup SSL Certificates
    needs: setup
    runs-on: ubuntu-latest
    if: ${{ !inputs.run_cert_fix_only }}
    steps:
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      - name: Add to known hosts
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
      - name: Check and create SSL certificates
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            set -ex  # Enable verbose logging and exit on errors
            
            # Define variables
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            DOMAIN="${{ secrets.VPN_DOMAIN }}"
            CERT_DIR="$DEPLOY_PATH/cert/$DOMAIN"
            
            echo "Checking for SSL certificates for domain: $DOMAIN"
            
            # Ensure the certificate directory exists
            mkdir -p "$CERT_DIR"
            
            # Check if certificates already exist in Let's Encrypt directory
            LETSENCRYPT_LIVE="/etc/letsencrypt/live/$DOMAIN"
            if [ -d "$LETSENCRYPT_LIVE" ] && [ -f "$LETSENCRYPT_LIVE/fullchain.pem" ] && [ -f "$LETSENCRYPT_LIVE/privkey.pem" ]; then
              echo "Found existing Let's Encrypt certificates for $DOMAIN"
              
              # Copy certificates to our directory
              sudo cp "$LETSENCRYPT_LIVE/fullchain.pem" "$CERT_DIR/"
              sudo cp "$LETSENCRYPT_LIVE/privkey.pem" "$CERT_DIR/"
              sudo chown -R $(whoami):$(whoami) "$CERT_DIR"
              echo "Copied Let's Encrypt certificates to $CERT_DIR"
            else
              echo "Let's Encrypt certificates not found at $LETSENCRYPT_LIVE"
              
              # Check if we already have certificates in our directory
              if [ -f "$CERT_DIR/fullchain.pem" ] && [ -f "$CERT_DIR/privkey.pem" ]; then
                echo "Found existing certificates in $CERT_DIR"
              else
                echo "No certificates found. Checking if Certbot is installed..."
                
                # Install Certbot if not available
                if ! command -v certbot &> /dev/null; then
                  echo "Installing Certbot..."
                  sudo apt-get update
                  sudo apt-get install -y certbot
                fi
                
                # Check if port 80 is in use by an existing service
                if lsof -i:80 > /dev/null; then
                  echo "Port 80 is in use. Stopping services to free port 80..."
                  # Stop services that might be using port 80
                  sudo systemctl stop nginx 2>/dev/null || true
                  sudo docker stop $(sudo docker ps -q --filter "publish=80") 2>/dev/null || true
                fi
                
                # Get certificate with Certbot
                echo "Obtaining new SSL certificate for $DOMAIN using Certbot..."
                sudo certbot certonly --standalone --non-interactive --agree-tos -d "$DOMAIN" --email "${{ secrets.ADMIN_EMAIL }}" || {
                  echo "Certbot failed to obtain certificates. Creating self-signed certificates as fallback."
                  
                  # Create self-signed certificates as fallback
                  echo "Creating self-signed certificates..."
                  openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
                    -keyout "$CERT_DIR/privkey.pem" \
                    -out "$CERT_DIR/fullchain.pem" \
                    -subj "/CN=$DOMAIN/O=3x-ui/C=US"
                  
                  echo "Self-signed certificates created at $CERT_DIR"
                }
                
                # If certificates were obtained from Let's Encrypt, copy them
                if [ -d "$LETSENCRYPT_LIVE" ] && [ -f "$LETSENCRYPT_LIVE/fullchain.pem" ]; then
                  sudo cp "$LETSENCRYPT_LIVE/fullchain.pem" "$CERT_DIR/"
                  sudo cp "$LETSENCRYPT_LIVE/privkey.pem" "$CERT_DIR/"
                fi
                
                # Ensure proper ownership
                sudo chown -R $(whoami):$(whoami) "$CERT_DIR"
              fi
            fi
            
            # Verify certificates
            echo "Verifying certificates..."
            if [ -f "$CERT_DIR/fullchain.pem" ] && [ -f "$CERT_DIR/privkey.pem" ]; then
              echo "‚úÖ Certificate files exist in $CERT_DIR"
              
              # Check certificate expiration (if openssl is available)
              if command -v openssl &> /dev/null; then
                echo "Certificate details:"
                openssl x509 -noout -subject -issuer -dates -in "$CERT_DIR/fullchain.pem"
              fi
            else
              echo "‚ùå Certificate files are missing from $CERT_DIR!"
              exit 1
            fi
          EOL

  deploy:
    name: üö¢ Deploy VPN Service
    needs: [setup, certificates]
    runs-on: ubuntu-latest
    if: ${{ !inputs.run_cert_fix_only }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      - name: Add to known hosts
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
      - name: Deploy from Git
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            set -ex  # Enable verbose logging and exit on error
            
            # Define deploy path
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            REPO_URL="https://github.com/${{ github.repository }}.git"
            
            echo "Current directory: $(pwd)"
            echo "Deploying to: $DEPLOY_PATH"
            
            # Ensure we're in the right directory
            cd "$DEPLOY_PATH" || {
              echo "ERROR: Unable to cd to $DEPLOY_PATH"
              exit 1
            }
            
            echo "Current directory after cd: $(pwd)"
            echo "Repository content before pulling:"
            ls -la
            
            # Make sure we're on the main branch
            git checkout main || git checkout -b main
            
            # Pull the latest code
            echo "Pulling latest code from $REPO_URL"
            git fetch origin
            git reset --hard origin/main
            
            echo "Repository content after pulling:"
            ls -la
            
            # Create .env from template if it doesn't exist
            if [ ! -f .env ]; then
              if [ -f .env.example ]; then
                cp .env.example .env
                echo "Created .env file from .env.example"
              elif [ -f env.local.example ]; then
                cp env.local.example .env
                echo "Created .env file from env.local.example"
              else
                echo "WARNING: No template file found for .env"
                touch .env
              fi
            fi
            
            # Make sure directories exist
            mkdir -p db cert logs
            
            # Ensure db/x-ui.db is a file, not a directory
            if [ -d "db/x-ui.db" ]; then
              echo "db/x-ui.db is a directory, fixing..."
              rm -rf db/x-ui.db
              touch db/x-ui.db
              echo "This is a placeholder database file. It was created by the workflow because db/x-ui.db was incorrectly a directory." > db/x-ui.db
              echo "Fixed db/x-ui.db"
            elif [ ! -f "db/x-ui.db" ]; then
              echo "db/x-ui.db doesn't exist, creating placeholder..."
              touch db/x-ui.db
              echo "This is a placeholder database file. It was created by the workflow because db/x-ui.db was missing." > db/x-ui.db
            fi
            
            # Verify SSL certificates exist before starting container
            DOMAIN="${{ secrets.VPN_DOMAIN }}"
            CERT_DIR="cert/$DOMAIN"
            echo "Verifying certificates for $DOMAIN in $CERT_DIR..."
            
            if [ ! -f "$CERT_DIR/fullchain.pem" ] || [ ! -f "$CERT_DIR/privkey.pem" ]; then
              echo "‚ö†Ô∏è Certificate files missing! Creating self-signed certificates as fallback..."
              
              # Ensure certificate directory exists
              mkdir -p "$CERT_DIR"
              
              # Create self-signed certificate
              openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
                -keyout "$CERT_DIR/privkey.pem" \
                -out "$CERT_DIR/fullchain.pem" \
                -subj "/CN=$DOMAIN/O=3x-ui/C=US" \
                -addext "subjectAltName=DNS:$DOMAIN"
              
              echo "‚úÖ Self-signed certificates created as fallback"
              
              # Set proper permissions
              chmod 644 "$CERT_DIR/fullchain.pem" 
              chmod 600 "$CERT_DIR/privkey.pem"
            else
              echo "‚úÖ Certificate files found in $CERT_DIR"
            fi
            
            # Check if docker-compose.yml exists
            if [ ! -f "docker-compose.yml" ]; then
              echo "ERROR: docker-compose.yml not found!"
              exit 1
            fi
            
            # Start containers
            echo "Starting containers with docker-compose"
            docker-compose pull
            docker-compose up -d
            
            echo "Deployment completed, checking container status:"
            docker-compose ps
          EOL
      - name: Verify deployment
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            set -ex  # Enable verbose logging and exit on error
            
            # Define deploy path
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            
            echo "Verifying deployment in $DEPLOY_PATH"
            cd "$DEPLOY_PATH" || {
              echo "ERROR: Unable to cd to $DEPLOY_PATH"
              exit 1
            }
            
            echo "Directory structure:"
            find . -type d -maxdepth 2 | sort
            
            echo "Critical files:"
            ls -la docker-compose.yml .env* db/ 2>/dev/null || echo "Some files may be missing"
            
            echo "Container status:"
            docker-compose ps
            
            echo "Running containers:"
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            
            echo "Container logs (last 10 lines):"
            docker-compose logs --tail=10
            
            echo "Checking if 3x-ui container is running:"
            if docker ps | grep -q '3x-ui'; then
              echo "‚úÖ 3x-ui container is running"
            else
              echo "‚ùå 3x-ui container is NOT running!"
              echo "Container details:"
              docker ps -a | grep 3x-ui || echo "No container found"
              echo "Container logs:"
              docker-compose logs 3x-ui
              exit 1
            fi
            
            echo "‚úÖ Deployment verification completed successfully"
          EOL

  verify:
    name: ‚úÖ Verify Deployment
    needs: deploy
    runs-on: ubuntu-latest
    if: ${{ !inputs.run_cert_fix_only }}
    steps:
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      - name: Add to known hosts
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
      - name: Verify deployment
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            set -ex  # Enable verbose logging and exit on error
            
            # Define deploy path
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            
            echo "Verifying deployment in $DEPLOY_PATH"
            cd "$DEPLOY_PATH" || {
              echo "ERROR: Unable to cd to $DEPLOY_PATH"
              exit 1
            }
            
            echo "Directory structure:"
            find . -type d -maxdepth 2 | sort
            
            echo "Critical files:"
            ls -la docker-compose.yml .env* db/ 2>/dev/null || echo "Some files may be missing"
            
            echo "Container status:"
            docker-compose ps
            
            echo "Running containers:"
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            
            echo "Container logs (last 10 lines):"
            docker-compose logs --tail=10
            
            echo "Checking if 3x-ui container is running:"
            if docker ps | grep -q '3x-ui'; then
              echo "‚úÖ 3x-ui container is running"
            else
              echo "‚ùå 3x-ui container is NOT running!"
              echo "Container details:"
              docker ps -a | grep 3x-ui || echo "No container found"
              echo "Container logs:"
              docker-compose logs 3x-ui
              exit 1
            fi
            
            echo "‚úÖ Deployment verification completed successfully"
          EOL

  logs:
    name: üìä Collect Logs
    needs: [deploy, verify]
    if: always() && !inputs.run_cert_fix_only
    runs-on: ubuntu-latest
    steps:
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      - name: Add to known hosts
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
      - name: Ensure logs directory is not empty
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} '
            set -e
            cd ${{ secrets.DEPLOY_PATH }}
            mkdir -p logs
            sudo chown $USER:$USER logs
            sudo chmod 777 logs
            if [ -z "$(ls -A logs)" ]; then
              echo "No logs found, creating dummy.log"
              sudo touch logs/dummy.log
              sudo chmod 666 logs/dummy.log
              echo "No logs available." | sudo tee logs/dummy.log
            fi
            echo "Contents of logs directory after ensuring dummy.log:"
            ls -l logs
            if [ -z "$(ls -A logs)" ]; then
              echo "ERROR: logs directory is still empty after attempting to create dummy.log"
              exit 1
            else
              echo "Logs directory is ready for SCP."
            fi
          '
      - name: Copy local dummy.log to server if needed
        run: |
          echo "No logs available." > dummy.log
          scp -o StrictHostKeyChecking=no dummy.log ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:${{ secrets.DEPLOY_PATH }}/logs/dummy.log
      - name: "Debug: List logs directory on server before SCP"
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} '
            cd ${{ secrets.DEPLOY_PATH }}
            echo "Listing logs directory before SCP:"
            ls -l logs
          '
      - name: Create local workflow_logs directory
        run: |
          mkdir -p workflow_logs
          echo "No logs available. Created by workflow." > workflow_logs/dummy.log
          echo "Created local workflow_logs directory with dummy file for artifact upload"
      - name: Download logs from server
        run: |
          # Create a directory for logs
          mkdir -p downloaded_logs
          # Try to download logs using scp, but don't fail if it doesn't work
          scp -o StrictHostKeyChecking=no -r ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:${{ secrets.DEPLOY_PATH }}/logs/* downloaded_logs/ || true
          # Check if we got any logs, if not create a dummy file
          if [ -z "$(ls -A downloaded_logs)" ]; then
            echo "No logs were downloaded, creating a dummy log file"
            echo "No logs were available on the server at the time of collection." > downloaded_logs/empty_logs.txt
          fi
          # Copy all downloaded logs to the workflow_logs directory
          cp -r downloaded_logs/* workflow_logs/ || true
          # List what we have
          echo "Contents of workflow_logs directory:"
          ls -la workflow_logs/
      - name: Archive logs
        uses: actions/upload-artifact@v4
        with:
          name: deployment-logs
          path: workflow_logs/
          retention-days: 7

  summary:
    name: üéâ Deployment Summary
    needs: [debug_info, validate, setup, certificates, deploy, verify, logs, cert_fix]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Generate Summary
        run: |
          echo "# 3x-ui VPN Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ inputs.run_cert_fix_only }}" == "true" ]]; then
            echo "‚úÖ **Certificate Fix**: Emergency fix applied" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚úÖ **Debug Info**: See debug_info job" >> $GITHUB_STEP_SUMMARY
            echo "‚úÖ **Configuration Validation**: See validate job" >> $GITHUB_STEP_SUMMARY
            echo "‚úÖ **SSH Setup**: See setup job" >> $GITHUB_STEP_SUMMARY
            echo "‚úÖ **SSL Certificates**: See certificates job" >> $GITHUB_STEP_SUMMARY
            echo "‚úÖ **Deployment**: See deploy job" >> $GITHUB_STEP_SUMMARY
            echo "‚úÖ **Verification**: See verify job" >> $GITHUB_STEP_SUMMARY
            echo "‚úÖ **Logs**: See logs job" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Access Information" >> $GITHUB_STEP_SUMMARY
          echo "üîó **Admin Panel**: https://${{ secrets.VPN_DOMAIN }}:54321/" >> $GITHUB_STEP_SUMMARY
      - name: Output Result
        run: |
          if [[ "${{ inputs.run_cert_fix_only }}" == "true" ]]; then
            echo "‚úÖ 3x-ui VPN certificate fix completed."
          else
            echo "‚úÖ 3x-ui VPN deployment workflow completed."
          fi 