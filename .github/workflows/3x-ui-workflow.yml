name: 3x-ui VPN Deployment

on:
  push:
    branches: [main]
    paths-ignore:
      - '**.md'
      - '.gitignore'
  workflow_dispatch: # Manual trigger

# Define default permissions
permissions:
  contents: read
  actions: read

# Global environment variables
env:
  DEFAULT_DOMAIN: service.foodshare.club
  DEFAULT_EMAIL: admin@example.com
  DOCKER_COMPOSE_VERSION: v2.24.6

jobs:
  validate:
    name: ğŸ” Validate Configuration
    runs-on: ubuntu-latest
    outputs:
      validation_status: ${{ steps.validate_compose.outputs.status }}
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        
      - name: ğŸ§° Install Docker Compose
        id: install_compose
        run: |
          echo "Installing Docker Compose version ${DOCKER_COMPOSE_VERSION}..."
          DOCKER_CONFIG=${DOCKER_CONFIG:-$HOME/.docker}
          mkdir -p $DOCKER_CONFIG/cli-plugins
          curl -SL https://github.com/docker/compose/releases/download/${DOCKER_COMPOSE_VERSION}/docker-compose-linux-x86_64 -o $DOCKER_CONFIG/cli-plugins/docker-compose
          chmod +x $DOCKER_CONFIG/cli-plugins/docker-compose
          docker compose version
      
      - name: ğŸ§° Validate Docker Compose
        id: validate_compose
        run: |
          echo "Validating Docker Compose file..."
          if [ ! -f docker-compose.yml ]; then
            echo "ERROR: docker-compose.yml not found!"
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Validate YAML syntax
          cat docker-compose.yml | python -c "import sys, yaml; yaml.safe_load(sys.stdin)" && echo "âœ… Valid YAML"
          
          # Check required services and ports
          grep -q "3x-ui:" docker-compose.yml && echo "âœ… 3x-ui service found"
          grep -q "443:443" docker-compose.yml && echo "âœ… HTTPS port (443) configured"
          grep -q "2053:2053" docker-compose.yml && echo "âœ… VPN Panel port (2053) configured"
          
          echo "status=success" >> $GITHUB_OUTPUT
      
      - name: ğŸ” Test Docker image
        run: |
          echo "Testing Docker image pull..."
          docker pull ghcr.io/mhsanaei/3x-ui:latest
          echo "âœ… Docker image pulled successfully"

  setup:
    name: ğŸ”§ Setup Connection
    needs: validate
    runs-on: ubuntu-latest
    outputs:
      connection_status: ${{ steps.verify_connection.outputs.status }}
    steps:
      - name: ğŸ”‘ Setup SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      
      - name: ğŸ” Add known hosts
        run: |
          echo "Setting up SSH access..."
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
          echo "âœ… SSH configuration completed"
      
      - name: ğŸ”— Verify SSH connection
        id: verify_connection
        run: |
          echo "Testing SSH connection..."
          if ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "echo 'âœ… SSH connection successful'"; then
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

  deploy:
    name: ğŸš€ Deploy Application
    needs: setup
    runs-on: ubuntu-latest
    outputs:
      deploy_log: ${{ steps.deployment.outputs.log_file }}
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        
      - name: ğŸ”‘ Setup SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      
      - name: ğŸ” Add known hosts
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
          
      - name: ğŸ”’ Execute Deployment
        id: deployment
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          script: |
            echo "Starting deployment process..."
            
            # Create directory structure if not exists
            echo "Creating deployment directories..."
            mkdir -p ${{ secrets.DEPLOY_PATH }}/{cert,logs,workflow_logs}
            chmod 755 ${{ secrets.DEPLOY_PATH }}
            chmod 700 ${{ secrets.DEPLOY_PATH }}/cert
            
            # Create timestamp
            TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
            DEPLOY_LOG="${{ secrets.DEPLOY_PATH }}/workflow_logs/deploy_${TIMESTAMP}.log"
            echo "Deployment started at $(date)" > $DEPLOY_LOG
            
            # Setup variables
            DOMAIN="${{ secrets.VPN_DOMAIN || env.DEFAULT_DOMAIN }}"
            ADMIN_EMAIL="${{ secrets.ADMIN_EMAIL || env.DEFAULT_EMAIL }}"
            echo "Domain: ${DOMAIN}" >> $DEPLOY_LOG
            
            # Install Docker Compose if needed
            if ! command -v docker-compose &> /dev/null && ! docker compose version &> /dev/null; then
              echo "Installing Docker Compose..." >> $DEPLOY_LOG
              DOCKER_CONFIG=${DOCKER_CONFIG:-$HOME/.docker}
              mkdir -p $DOCKER_CONFIG/cli-plugins
              curl -SL https://github.com/docker/compose/releases/download/${DOCKER_COMPOSE_VERSION}/docker-compose-linux-x86_64 -o $DOCKER_CONFIG/cli-plugins/docker-compose
              chmod +x $DOCKER_CONFIG/cli-plugins/docker-compose
              # Also create a symlink for compatibility
              if [ ! -f /usr/local/bin/docker-compose ]; then
                ln -s $DOCKER_CONFIG/cli-plugins/docker-compose /usr/local/bin/docker-compose
              fi
              echo "Docker Compose installed:" >> $DEPLOY_LOG
              docker compose version >> $DEPLOY_LOG 2>&1
            fi
            
            # Install certbot if needed
            if ! command -v certbot &> /dev/null; then
              echo "Installing certbot..." >> $DEPLOY_LOG
              apt-get update
              apt-get install -y certbot
            fi
            
            # Stop any running containers
            echo "Stopping any running containers..." >> $DEPLOY_LOG
            cd ${{ secrets.DEPLOY_PATH }}
            docker compose down >> $DEPLOY_LOG 2>&1 || true
            
            # Generate SSL certificate if needed
            if [ ! -f "${{ secrets.DEPLOY_PATH }}/cert/fullchain.pem" ]; then
              echo "Generating SSL certificate for ${DOMAIN}..." >> $DEPLOY_LOG
              certbot certonly --standalone --preferred-challenges http --agree-tos -n \
                -d ${DOMAIN} -m ${ADMIN_EMAIL} \
                --cert-path=${{ secrets.DEPLOY_PATH }}/cert/cert.pem \
                --fullchain-path=${{ secrets.DEPLOY_PATH }}/cert/fullchain.pem \
                --chain-path=${{ secrets.DEPLOY_PATH }}/cert/chain.pem \
                --key-path=${{ secrets.DEPLOY_PATH }}/cert/privkey.pem \
                --config-dir=${{ secrets.DEPLOY_PATH }}/cert/letsencrypt \
                --work-dir=${{ secrets.DEPLOY_PATH }}/cert/letsencrypt \
                --logs-dir=${{ secrets.DEPLOY_PATH }}/logs/letsencrypt
            else
              echo "SSL certificate already exists, checking expiry..." >> $DEPLOY_LOG
              CERT_EXPIRY=$(openssl x509 -enddate -noout -in "${{ secrets.DEPLOY_PATH }}/cert/fullchain.pem" | cut -d= -f2)
              echo "Certificate expires on: ${CERT_EXPIRY}" >> $DEPLOY_LOG
            fi
            
            # Set proper permissions
            chmod 600 ${{ secrets.DEPLOY_PATH }}/cert/*.pem
            
            # Copy docker-compose.yml
            echo "Copying configuration files..." >> $DEPLOY_LOG
            cp ${{ github.workspace }}/docker-compose.yml ${{ secrets.DEPLOY_PATH }}/
            
            # Create .env file
            echo "Setting up environment file..." >> $DEPLOY_LOG
            cat > ${{ secrets.DEPLOY_PATH }}/.env << EOL
            VPN_DOMAIN=${DOMAIN}
            ADMIN_EMAIL=${ADMIN_EMAIL}
            PANEL_PATH=${{ secrets.PANEL_PATH || 'BXv8SI7gBe' }}
            XRAY_VMESS_AEAD_FORCED=false
            EOL
            
            # Start service
            echo "Starting 3x-ui container..." >> $DEPLOY_LOG
            cd ${{ secrets.DEPLOY_PATH }}
            docker compose pull >> $DEPLOY_LOG 2>&1
            docker compose up -d >> $DEPLOY_LOG 2>&1
            
            # Log completion
            echo "Deployment completed at $(date)" >> $DEPLOY_LOG
            ln -sf $DEPLOY_LOG "${{ secrets.DEPLOY_PATH }}/workflow_logs/latest_deploy.log"
            echo "âœ… Deployment process completed"
            echo "log_file=${DEPLOY_LOG}" >> $GITHUB_OUTPUT

  verify:
    name: âœ… Verify Deployment
    needs: deploy
    runs-on: ubuntu-latest
    outputs:
      verification_status: ${{ steps.service_check.outputs.status }}
      verify_log: ${{ steps.service_check.outputs.log_file }}
    steps:
      - name: ğŸ”‘ Setup SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      
      - name: ğŸ” Add known hosts
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
          
      - name: âœ… Check Service Health
        id: service_check
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          script: |
            echo "Verifying service health..."
            cd ${{ secrets.DEPLOY_PATH }}
            
            # Create a timestamp for logs
            TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
            VERIFY_LOG="${{ secrets.DEPLOY_PATH }}/workflow_logs/verify_${TIMESTAMP}.log"
            echo "Verification started at $(date)" > $VERIFY_LOG
            
            # Wait for the container to stabilize
            echo "Waiting for service to stabilize..."
            sleep 30
            
            # Check container status
            CONTAINER_STATUS=$(docker ps --filter "name=3x-ui" --format "{{.Status}}")
            echo "Container status: $CONTAINER_STATUS" >> $VERIFY_LOG
            
            # Check container health
            HEALTH_STATUS=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}no-healthcheck{{end}}' 3x-ui)
            echo "Health status: $HEALTH_STATUS" >> $VERIFY_LOG
            
            # Check service is responding
            DOMAIN="${{ secrets.VPN_DOMAIN || env.DEFAULT_DOMAIN }}"
            curl -s -o /dev/null -w "Admin panel HTTP status: %{http_code}\n" http://localhost:54321/login >> $VERIFY_LOG
            
            # Log container logs
            echo "Container logs:" >> $VERIFY_LOG
            docker compose logs --tail=30 >> $VERIFY_LOG
            
            # Finish verification
            echo "Verification completed at $(date)" >> $VERIFY_LOG
            ln -sf $VERIFY_LOG "${{ secrets.DEPLOY_PATH }}/workflow_logs/latest_verify.log"
            
            if [[ -n "$CONTAINER_STATUS" ]]; then
              echo "âœ… Service verification passed. Container is running."
              echo "status=success" >> $GITHUB_OUTPUT
            else
              echo "âŒ Service verification failed. Container is not running."
              echo "status=failed" >> $GITHUB_OUTPUT
              exit 1
            fi
            echo "log_file=${VERIFY_LOG}" >> $GITHUB_OUTPUT

  logs:
    name: ğŸ“Š Collect Logs
    needs: [deploy, verify]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: ğŸ“¥ Download Logs
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          source: ${{ secrets.DEPLOY_PATH }}/workflow_logs/latest_*.log
          target: ./workflow_logs
          strip_components: 2
      
      - name: ğŸ“¦ Archive logs
        uses: actions/upload-artifact@v4
        with:
          name: deployment-logs
          path: ./workflow_logs/
          retention-days: 7
          
  summary:
    name: ğŸ‰ Deployment Summary
    needs: [validate, setup, deploy, verify, logs]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: ğŸ“ Generate Summary
        run: |
          echo "# 3x-ui VPN Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Validation Status
          if [[ "${{ needs.validate.outputs.validation_status }}" == "success" ]]; then
            echo "âœ… **Configuration Validation**: Passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Configuration Validation**: Failed" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Connection Status
          if [[ "${{ needs.setup.outputs.connection_status }}" == "success" ]]; then
            echo "âœ… **SSH Connection**: Established" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **SSH Connection**: Failed" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Deployment Status
          if [[ "${{ needs.deploy.result }}" == "success" ]]; then
            echo "âœ… **Deployment**: Completed" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Deployment**: Failed" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Verification Status
          if [[ "${{ needs.verify.outputs.verification_status }}" == "success" ]]; then
            echo "âœ… **Service Verification**: Passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Service Verification**: Failed" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Logs Status
          if [[ "${{ needs.logs.result }}" == "success" ]]; then
            echo "âœ… **Logs Collection**: Completed" >> $GITHUB_STEP_SUMMARY
          else
            echo "âš ï¸ **Logs Collection**: Incomplete" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Access Information" >> $GITHUB_STEP_SUMMARY
          echo "ğŸ”— **Admin Panel**: https://${{ secrets.VPN_DOMAIN || env.DEFAULT_DOMAIN }}:2053/${{ secrets.PANEL_PATH || 'BXv8SI7gBe' }}/" >> $GITHUB_STEP_SUMMARY
          
      - name: ğŸ“¢ Output Result
        run: |
          if [[ "${{ needs.verify.outputs.verification_status }}" == "success" ]]; then
            echo "âœ… 3x-ui VPN has been deployed successfully"
          else
            echo "âŒ 3x-ui VPN deployment encountered issues"
          fi
          echo "ğŸ“Š Logs have been archived as artifacts"
          echo "ğŸ”— Admin panel: https://${{ secrets.VPN_DOMAIN || env.DEFAULT_DOMAIN }}:2053/${{ secrets.PANEL_PATH || 'BXv8SI7gBe' }}/" 