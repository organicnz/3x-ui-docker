permissions:
  contents: read

name: 3x-ui VPN Service Management

on:
  workflow_dispatch:
  push:
    branches:
      - main
    paths-ignore:
      - README.md
      - .gitignore
      - logs/**
      - workflow_logs/**
  schedule:
    - cron: 0 2 * * *  # Run daily at 2 AM UTC for backups

jobs:
  debug_info:
    name: üêõ Debug Workflow Info
    runs-on: ubuntu-latest
    steps:
      - name: Display Trigger Info
        env:
          GH_EVENT_NAME: ${{ github.event_name }}
          GH_REF_NAME: ${{ github.ref_name }}
          GH_BASE_REF: ${{ github.base_ref }}
          GH_REF_TYPE: ${{ github.ref_type }}
          GH_REPOSITORY: ${{ github.repository }}
          GH_RUN_ID: ${{ github.run_id }}
        run: |
          echo "Workflow triggered by: $GH_EVENT_NAME"
          echo "Ref name: $GH_REF_NAME"
          echo "Base ref: $GH_BASE_REF"
          echo "Ref type: $GH_REF_TYPE"
          echo "Repository: $GH_REPOSITORY"
          echo "Run ID: $GH_RUN_ID"
          echo "Auto-deploy mode: enabled"

  cert_fix:
    name: üöë Emergency Certificate Fix
    runs-on: ubuntu-latest
    if: false  # Disabled by default, use separate workflow for cert fixes
    steps:
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      - name: Add to known hosts
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
      - name: Fix SSL Certificates
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            set -ex  # Enable verbose logging and exit on errors
            
            # Define variables
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            DOMAIN="${{ secrets.VPN_DOMAIN }}"
            CERT_DIR="$DEPLOY_PATH/cert/$DOMAIN"
            
            echo "üîç Checking current container status..."
            cd "$DEPLOY_PATH"
            docker-compose ps
            
            echo "üìÅ Creating certificate directory..."
            mkdir -p "$CERT_DIR"
            
            echo "üîë Creating self-signed certificates..."
            openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
              -keyout "$CERT_DIR/privkey.pem" \
              -out "$CERT_DIR/fullchain.pem" \
              -subj "/CN=$DOMAIN/O=3x-ui/C=US" \
              -addext "subjectAltName=DNS:$DOMAIN"
            
            echo "üîí Setting permissions..."
            chmod 644 "$CERT_DIR/fullchain.pem"
            chmod 600 "$CERT_DIR/privkey.pem"
            
            echo "üîÑ Restarting 3x-ui container..."
            docker-compose restart 3x-ui
            
            echo "‚úÖ Certificate fix complete!"
            echo "üìã Container status after fix:"
            docker-compose ps
            
            echo "üìã Certificate details:"
            openssl x509 -noout -text -in "$CERT_DIR/fullchain.pem" | grep -E "Subject:|Issuer:|Not Before:|Not After :|DNS:"
            
            echo "üìã Container logs (last 10 lines):"
            sleep 5  # Give the container time to start
            docker-compose logs --tail=10 3x-ui
          EOL
      - name: Add to workflow summary
        run: |
          echo "# üöë Certificate Emergency Fix" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Emergency certificate fix was applied to ensure the service has valid SSL certificates." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "For production use, consider running the full workflow to acquire proper Let's Encrypt certificates." >> $GITHUB_STEP_SUMMARY

  validate:
    name: üîç Validate Configuration
    runs-on: ubuntu-latest
    needs: debug_info
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Validate Docker Compose
        run: |
          if [ ! -f docker-compose.yml ]; then
            echo "ERROR: docker-compose.yml not found!"
            exit 1
          fi
          cat docker-compose.yml | python3 -c "import sys, yaml; yaml.safe_load(sys.stdin)" && echo "‚úÖ Valid YAML"
          grep -q "3x-ui:" docker-compose.yml && echo "‚úÖ 3x-ui service found"
          grep -q "54321:54321" docker-compose.yml && echo "‚úÖ Admin panel port (54321) configured"

  setup:
    name: üöÄ Setup Server
    needs: validate
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      - name: Add to known hosts
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
      - name: Check SSH connectivity
        run: |
          ssh -o BatchMode=yes -o ConnectTimeout=10 ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            echo '‚úÖ SSH connection successful'
          EOL
      - name: Fix Git Repository
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            set -ex  # Enable verbose logging and exit on error
            
            # Define variables
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            REPO_URL="https://github.com/${{ github.repository }}.git"
            
            # Colors for better output readability
            RED='\033[0;31m'
            GREEN='\033[0;32m'
            YELLOW='\033[1;33m'
            BLUE='\033[0;34m'
            NC='\033[0m' # No Color
            
            echo -e "${BLUE}==== Fixing Git Repository ====${NC}"
            
            # Ensure directory exists
            if [ ! -d "$DEPLOY_PATH" ]; then
              echo -e "${YELLOW}Directory $DEPLOY_PATH doesn't exist. Creating...${NC}"
              mkdir -p "$DEPLOY_PATH"
            fi
            
            # Go to directory
            cd "$DEPLOY_PATH" || {
              echo -e "${RED}Failed to cd to $DEPLOY_PATH${NC}"
              exit 1
            }

            # Check if .git directory exists
            if [ ! -d ".git" ]; then
              echo -e "${YELLOW}No Git repository found. Initializing...${NC}"
              git init
              git remote add origin "$REPO_URL"
            else
              echo -e "${GREEN}Git repository exists. Checking configuration...${NC}"
              
              # Check if origin is set correctly
              CURRENT_REMOTE=$(git remote get-url origin 2>/dev/null || echo "")
              if [ "$CURRENT_REMOTE" != "$REPO_URL" ]; then
                echo -e "${YELLOW}Remote URL is incorrect or missing. Fixing...${NC}"
                git remote remove origin 2>/dev/null || true
                git remote add origin "$REPO_URL"
              fi
              
              # Check if Git is in a detached HEAD state
              if git symbolic-ref -q HEAD >/dev/null; then
                echo -e "${GREEN}Repository has a proper HEAD reference.${NC}"
              else
                echo -e "${YELLOW}Repository is in detached HEAD state. Fixing...${NC}"
                # Reset to main branch
                git checkout -b temp_branch
                git branch -D main 2>/dev/null || true
                git checkout -b main
                git branch -D temp_branch
              fi
            fi
            
            # Fetch latest changes
            echo -e "${BLUE}Fetching latest changes...${NC}"
            git fetch origin || {
              echo -e "${RED}Failed to fetch. Trying with --depth=1...${NC}"
              git fetch origin --depth=1
            }
            
            # Check if we have the main branch
            if ! git show-ref --verify --quiet refs/heads/main; then
              echo -e "${YELLOW}Creating main branch...${NC}"
              git checkout -b main origin/main || {
                echo -e "${RED}Failed to checkout main branch. Creating empty main branch...${NC}"
                git checkout --orphan main
                git reset --hard
                git pull origin main --allow-unrelated-histories || true
              }
            else
              echo -e "${GREEN}Main branch exists. Checking out...${NC}"
              git checkout main
            fi
            
            # Discard local changes
            echo -e "${YELLOW}Discarding any local changes...${NC}"
            git reset --hard HEAD || true
            git clean -fdx || true
            
            # Pull latest changes
            echo -e "${BLUE}Pulling latest changes...${NC}"
            git pull origin main || {
              echo -e "${RED}Failed to pull. Trying with --allow-unrelated-histories...${NC}"
              git pull origin main --allow-unrelated-histories || {
                echo -e "${RED}Failed to pull even with --allow-unrelated-histories.${NC}"
                echo -e "${YELLOW}Recreating repository from scratch...${NC}"
                
                # Backup existing data
                cd ..
                TIMESTAMP=$(date +%s)
                BACKUP_DIR="/tmp/3x-ui-backup-$TIMESTAMP"
                mkdir -p "$BACKUP_DIR"
                
                if [ -d "$DEPLOY_PATH/db" ]; then
                  cp -r "$DEPLOY_PATH/db" "$BACKUP_DIR/"
                fi
                
                if [ -d "$DEPLOY_PATH/cert" ]; then
                  cp -r "$DEPLOY_PATH/cert" "$BACKUP_DIR/"
                fi
                
                if [ -d "$DEPLOY_PATH/logs" ]; then
                  cp -r "$DEPLOY_PATH/logs" "$BACKUP_DIR/"
                fi
                
                if [ -f "$DEPLOY_PATH/.env" ]; then
                  cp "$DEPLOY_PATH/.env" "$BACKUP_DIR/"
                fi
                
                # Remove and clone fresh
                mv "$DEPLOY_PATH" "${DEPLOY_PATH}_broken_$TIMESTAMP"
                git clone "$REPO_URL" "$DEPLOY_PATH"
                
                # Restore data
                cd "$DEPLOY_PATH"
                
                # Restore database files
                if [ -d "$BACKUP_DIR/db" ]; then
                  cp -r "$BACKUP_DIR/db/"* db/ 2>/dev/null || true
                else
                  mkdir -p db
                fi
                
                # Restore certificate files
                if [ -d "$BACKUP_DIR/cert" ]; then
                  cp -r "$BACKUP_DIR/cert/"* cert/ 2>/dev/null || true
                else
                  mkdir -p cert
                fi
                
                # Restore log files
                if [ -d "$BACKUP_DIR/logs" ]; then
                  cp -r "$BACKUP_DIR/logs/"* logs/ 2>/dev/null || true
                else
                  mkdir -p logs
                fi
                
                # Restore .env file
                if [ -f "$BACKUP_DIR/.env" ]; then
                  cp "$BACKUP_DIR/.env" .env
                fi
                
                echo -e "${GREEN}Repository recreated from scratch and data restored.${NC}"
              }
            }
            
            # Verify repository has files
            echo -e "${BLUE}Verifying repository contents...${NC}"
            FILE_COUNT=$(find . -type f -not -path "./.git/*" | wc -l)
            
            if [ "$FILE_COUNT" -lt 5 ]; then
              echo -e "${RED}Repository has very few files ($FILE_COUNT). Something may be wrong.${NC}"
              ls -la
            else
              echo -e "${GREEN}Repository has $FILE_COUNT files. Looks good!${NC}"
            fi
            
            # Check for docker-compose.yml
            if [ -f "docker-compose.yml" ]; then
              echo -e "${GREEN}docker-compose.yml exists. Repository appears to be valid.${NC}"
            else
              echo -e "${RED}docker-compose.yml is missing! Repository may be incomplete.${NC}"
              
              # Try again with a clean clone
              echo -e "${YELLOW}Attempting a clean clone...${NC}"
              cd ..
              TIMESTAMP=$(date +%s)
              mv "$DEPLOY_PATH" "${DEPLOY_PATH}_incomplete_$TIMESTAMP"
              git clone "$REPO_URL" "$DEPLOY_PATH"
              
              cd "$DEPLOY_PATH"
              if [ -f "docker-compose.yml" ]; then
                echo -e "${GREEN}Clean clone successful! docker-compose.yml now exists.${NC}"
                
                # Restore data from previous attempt
                OLD_PATH="${DEPLOY_PATH}_incomplete_$TIMESTAMP"
                
                mkdir -p db cert logs
                
                # Copy data from previous attempt
                if [ -d "$OLD_PATH/db" ]; then
                  cp -r "$OLD_PATH/db/"* db/ 2>/dev/null || true
                fi
                
                if [ -d "$OLD_PATH/cert" ]; then
                  cp -r "$OLD_PATH/cert/"* cert/ 2>/dev/null || true
                fi
                
                if [ -d "$OLD_PATH/logs" ]; then
                  cp -r "$OLD_PATH/logs/"* logs/ 2>/dev/null || true
                fi
                
                if [ -f "$OLD_PATH/.env" ]; then
                  cp "$OLD_PATH/.env" .env
                fi
              else
                echo -e "${RED}Clean clone also failed. Manual intervention may be required.${NC}"
                exit 1
              fi
            fi
            
            # Ensure required directories exist
            echo -e "${YELLOW}Ensuring required directories exist...${NC}"
            mkdir -p db cert logs cert/service.foodshare.club
            
            # Set proper permissions
            echo -e "${YELLOW}Setting proper permissions...${NC}"
            chmod -R 755 .
            chmod -R 777 logs
            if [ -f "db/x-ui.db" ]; then
              chmod 644 db/x-ui.db
            else
              touch db/x-ui.db
              chmod 644 db/x-ui.db
            fi
            
            echo -e "${GREEN}Git repository is now fixed and ready for deployment!${NC}"
            echo -e "${BLUE}Repository information:${NC}"
            git log -n 3 --oneline
            git status
            ls -la
          EOL
      - name: Setup SSL Certificates
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            set -ex  # Enable verbose logging and exit on error
            
            # Define variables
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            DOMAIN="${{ secrets.VPN_DOMAIN }}"
            CERT_DIR="$DEPLOY_PATH/cert/$DOMAIN"
            
            # Colors for output
            RED='\033[0;31m'
            GREEN='\033[0;32m'
            YELLOW='\033[1;33m'
            BLUE='\033[0;34m'
            NC='\033[0m' # No Color
            
            echo -e "${BLUE}==== Setting up SSL Certificates ====${NC}"
            
            # Check if we're already in the deploy path, if not change to it
            if [ "$(pwd)" != "$DEPLOY_PATH" ]; then
              cd "$DEPLOY_PATH" || {
                echo -e "${RED}Failed to cd to $DEPLOY_PATH${NC}"
                exit 1
              }
            fi
            
            # Create certificate directory if it doesn't exist
            if [ ! -d "$CERT_DIR" ]; then
              echo -e "${YELLOW}Creating certificate directory: $CERT_DIR${NC}"
              mkdir -p "$CERT_DIR"
            else
              echo -e "${GREEN}Certificate directory exists.${NC}"
            fi
            
            # Check if certificate files exist
            if [ ! -f "$CERT_DIR/fullchain.pem" ] || [ ! -f "$CERT_DIR/privkey.pem" ]; then
              echo -e "${YELLOW}Certificates missing. Generating self-signed certificates...${NC}"
              
              # Generate self-signed certificate
              openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
                -keyout "$CERT_DIR/privkey.pem" \
                -out "$CERT_DIR/fullchain.pem" \
                -subj "/CN=$DOMAIN/O=3x-ui/C=US" \
                -addext "subjectAltName=DNS:$DOMAIN" || {
                  echo -e "${RED}Failed to generate certificates. Trying alternate method...${NC}"
                  
                  # Fallback method - simpler OpenSSL command
                  openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
                    -keyout "$CERT_DIR/privkey.pem" \
                    -out "$CERT_DIR/fullchain.pem" \
                    -subj "/CN=$DOMAIN" || {
                      echo -e "${RED}Both certificate generation methods failed.${NC}"
                      exit 1
                    }
                }
              
              echo -e "${GREEN}Self-signed certificates generated successfully.${NC}"
            else
              echo -e "${GREEN}Certificates already exist.${NC}"
              
              # Check certificate expiration
              echo -e "${YELLOW}Checking certificate expiration...${NC}"
              END_DATE=$(openssl x509 -enddate -noout -in "$CERT_DIR/fullchain.pem" | cut -d= -f2)
              END_EPOCH=$(date -d "$END_DATE" +%s 2>/dev/null || date -j -f "%b %d %H:%M:%S %Y %Z" "$END_DATE" +%s 2>/dev/null)
              NOW_EPOCH=$(date +%s)
              DAYS_LEFT=$(( ($END_EPOCH - $NOW_EPOCH) / 86400 ))
              
              if [ $? -eq 0 ] && [ $DAYS_LEFT -lt 30 ]; then
                echo -e "${YELLOW}Certificate expires in $DAYS_LEFT days. Renewing...${NC}"
                
                # Backup existing certificates
                cp "$CERT_DIR/fullchain.pem" "$CERT_DIR/fullchain.pem.bak"
                cp "$CERT_DIR/privkey.pem" "$CERT_DIR/privkey.pem.bak"
                
                # Generate new self-signed certificate
                openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
                  -keyout "$CERT_DIR/privkey.pem" \
                  -out "$CERT_DIR/fullchain.pem" \
                  -subj "/CN=$DOMAIN/O=3x-ui/C=US" \
                  -addext "subjectAltName=DNS:$DOMAIN" || {
                    echo -e "${RED}Failed to renew certificates. Restoring backup...${NC}"
                    cp "$CERT_DIR/fullchain.pem.bak" "$CERT_DIR/fullchain.pem"
                    cp "$CERT_DIR/privkey.pem.bak" "$CERT_DIR/privkey.pem"
                  }
                
                echo -e "${GREEN}Certificate renewed successfully.${NC}"
              else
                echo -e "${GREEN}Certificate is still valid.${NC}"
              fi
            fi
            
            # Set proper permissions
            echo -e "${YELLOW}Setting proper permissions on certificates...${NC}"
            chmod 644 "$CERT_DIR/fullchain.pem"
            chmod 600 "$CERT_DIR/privkey.pem"
            
            # Verify certificates
            echo -e "${BLUE}Verifying certificates...${NC}"
            if openssl x509 -in "$CERT_DIR/fullchain.pem" -noout -text &>/dev/null; then
              echo -e "${GREEN}Certificate is valid.${NC}"
              openssl x509 -in "$CERT_DIR/fullchain.pem" -noout -subject -issuer -dates
            else
              echo -e "${RED}Certificate verification failed.${NC}"
            fi
            
            # Make a symbolic link to the service.foodshare.club directory in the right place
            echo -e "${YELLOW}Ensuring certificates are accessible to 3x-ui container...${NC}"
            if [ ! -d "/root/cert" ]; then
              echo -e "${YELLOW}Container root certificate directory doesn't exist. This is fine in workflow.${NC}"
            fi
            
            # Finally, create symlink from cert/domain/ to cert/
            # This creates fallback certs in the root cert directory in case the container 
            # looks there instead of the subfolder
            if [ ! -f "$DEPLOY_PATH/cert/fullchain.pem" ]; then
              echo -e "${YELLOW}Creating fallback symlinks in cert directory...${NC}"
              ln -sf "$CERT_DIR/fullchain.pem" "$DEPLOY_PATH/cert/fullchain.pem" || cp "$CERT_DIR/fullchain.pem" "$DEPLOY_PATH/cert/fullchain.pem"
              ln -sf "$CERT_DIR/privkey.pem" "$DEPLOY_PATH/cert/privkey.pem" || cp "$CERT_DIR/privkey.pem" "$DEPLOY_PATH/cert/privkey.pem"
            fi
            
            echo -e "${GREEN}Certificate setup complete!${NC}"
          EOL
      - name: Install Docker if not installed
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
          if ! command -v docker &> /dev/null; then
            echo "Installing Docker..."
            curl -fsSL https://get.docker.com -o get-docker.sh
            sudo sh get-docker.sh
            sudo usermod -aG docker $USER
          else
            echo "Docker already installed."
          fi
          if ! command -v docker-compose &> /dev/null; then
            echo "Installing Docker Compose..."
            sudo curl -L "https://github.com/docker/compose/releases/download/v2.15.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
          else
            echo "Docker Compose already installed."
          fi
          EOL

  deploy:
    name: üö¢ Deploy VPN Service
    needs: [setup]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      - name: Add to known hosts
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
      - name: Deploy from Git
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            set -ex  # Enable verbose logging and exit on error
            
            # Define variables
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            REPO_URL="https://github.com/${{ github.repository }}.git"
            DEPLOY_BRANCH="main"
            REPO_ROOT=$(dirname "$DEPLOY_PATH")
            REPO_DIR=$(basename "$DEPLOY_PATH")
            
            # Colors for output
            RED='\033[0;31m'
            GREEN='\033[0;32m'
            YELLOW='\033[1;33m'
            NC='\033[0m' # No Color
            
            echo -e "${GREEN}==== Deploying 3x-ui VPN Service ====${NC}"
            
            # Check current state 
            echo -e "${YELLOW}Checking repository at $DEPLOY_PATH${NC}"
            if [ -d "$DEPLOY_PATH" ]; then
              cd "$DEPLOY_PATH"
              
              # Count files to see if repository has content
              FILE_COUNT=$(find . -type f | wc -l)
              if [ "$FILE_COUNT" -lt 5 ]; then
                echo -e "${RED}Repository has minimal files ($FILE_COUNT found). Recreating...${NC}"
                NEEDS_RECREATE=true
              else
                echo -e "${GREEN}Repository has $FILE_COUNT files.${NC}"
                # Check if docker-compose.yml exists
                if [ ! -f "docker-compose.yml" ]; then
                  echo -e "${RED}Missing docker-compose.yml. Recreating repository...${NC}"
                  NEEDS_RECREATE=true
                else
                  echo -e "${GREEN}docker-compose.yml exists.${NC}"
                  NEEDS_RECREATE=false
                fi
              fi
            else
              echo -e "${YELLOW}Repository directory does not exist. Creating...${NC}"
              mkdir -p "$DEPLOY_PATH"
              NEEDS_RECREATE=true
            fi
            
            # Backup important data first
            echo -e "${YELLOW}Backing up important data${NC}"
            BACKUP_DIR="/tmp/3x-ui-backup-$(date +%s)"
            mkdir -p "$BACKUP_DIR"
            
            if [ -d "$DEPLOY_PATH" ]; then
              cd "$DEPLOY_PATH"
              
              # Backup essential files
              if [ -f ".env" ]; then
                cp .env "$BACKUP_DIR/"
                echo -e "${GREEN}Backed up .env file${NC}"
              fi
              
              if [ -d "db" ]; then
                mkdir -p "$BACKUP_DIR/db"
                cp -r db/* "$BACKUP_DIR/db/" 2>/dev/null || true
                echo -e "${GREEN}Backed up database files${NC}"
              fi
              
              if [ -d "logs" ]; then
                mkdir -p "$BACKUP_DIR/logs"
                cp -r logs/* "$BACKUP_DIR/logs/" 2>/dev/null || true
                echo -e "${GREEN}Backed up log files${NC}"
              fi
              
              if [ -d "cert" ]; then
                mkdir -p "$BACKUP_DIR/cert"
                cp -r cert/* "$BACKUP_DIR/cert/" 2>/dev/null || true
                echo -e "${GREEN}Backed up certificate files${NC}"
              fi
            fi
            
            # Recreate repository if needed
            if [ "$NEEDS_RECREATE" = true ]; then
              # Go to parent directory
              cd "$REPO_ROOT"
              
              # Rename old directory if it exists
              if [ -d "$REPO_DIR" ]; then
                TIMESTAMP=$(date +%s)
                mv "$REPO_DIR" "${REPO_DIR}_old_${TIMESTAMP}"
                echo -e "${YELLOW}Renamed old directory to ${REPO_DIR}_old_${TIMESTAMP}${NC}"
              fi
              
              # Clone fresh repository
              echo -e "${YELLOW}Cloning fresh repository from $REPO_URL${NC}"
              git clone -b "$DEPLOY_BRANCH" "$REPO_URL" "$REPO_DIR"
              
              # Enter repository
              cd "$REPO_DIR"
              
              # Verify clone was successful
              if [ ! -f "docker-compose.yml" ]; then
                echo -e "${RED}ERROR: docker-compose.yml not found after cloning. Check repository.${NC}"
                ls -la
                exit 1
              else
                echo -e "${GREEN}Repository cloned successfully with docker-compose.yml present.${NC}"
              fi
            else
              # If we don't need to recreate, just pull latest changes
              cd "$DEPLOY_PATH"
              echo -e "${YELLOW}Pulling latest changes...${NC}"
              git pull origin "$DEPLOY_BRANCH"
            fi
            
            # Make sure we're in the repository
            cd "$DEPLOY_PATH"
            
            # Restore data from backup
            if [ -d "$BACKUP_DIR" ]; then
              echo -e "${YELLOW}Restoring from backup...${NC}"
              
              # Restore .env
              if [ -f "$BACKUP_DIR/.env" ]; then
                cp "$BACKUP_DIR/.env" .env
                echo -e "${GREEN}Restored .env file${NC}"
              fi
              
              # Restore database
              if [ -d "$BACKUP_DIR/db" ] && [ "$(ls -A "$BACKUP_DIR/db" 2>/dev/null)" ]; then
                mkdir -p db
                cp -r "$BACKUP_DIR/db/"* db/ 2>/dev/null || true
                echo -e "${GREEN}Restored database files${NC}"
              fi
              
              # Restore logs
              if [ -d "$BACKUP_DIR/logs" ] && [ "$(ls -A "$BACKUP_DIR/logs" 2>/dev/null)" ]; then
                mkdir -p logs
                cp -r "$BACKUP_DIR/logs/"* logs/ 2>/dev/null || true
                echo -e "${GREEN}Restored log files${NC}"
              fi
              
              # Restore certificates
              if [ -d "$BACKUP_DIR/cert" ] && [ "$(ls -A "$BACKUP_DIR/cert" 2>/dev/null)" ]; then
                mkdir -p cert
                cp -r "$BACKUP_DIR/cert/"* cert/ 2>/dev/null || true
                echo -e "${GREEN}Restored certificate files${NC}"
              fi
            fi
            
            # Create default .env if it doesn't exist
            if [ ! -f ".env" ]; then
              if [ -f ".env.example" ]; then
                cp .env.example .env
                echo "üìÑ Created .env file from template"
              else
                touch .env
                echo "üìÑ Created empty .env file"
              fi
            fi
            
            # Ensure required directories exist
            echo "üìÅ Ensuring required directories exist"
            mkdir -p db cert logs cert/service.foodshare.club docs
            
            # Ensure db/x-ui.db exists and is a file
            if [ -d "db/x-ui.db" ]; then
              echo "‚ö†Ô∏è db/x-ui.db is a directory, fixing..."
              rm -rf db/x-ui.db
              touch db/x-ui.db
              echo "‚úÖ Fixed db/x-ui.db"
            elif [ ! -f "db/x-ui.db" ]; then
              echo "üìÑ Creating db/x-ui.db placeholder"
              touch db/x-ui.db
            fi
            
            # Set up Docker networks
            echo "üåê Setting up Docker networks"
            docker network create web 2>/dev/null || true
            docker network create no-zero-trust-cloudflared 2>/dev/null || true
            
            # Deploy containers
            echo "üöÄ Deploying containers"
            docker-compose pull
            docker-compose down
            docker-compose up -d
            
            echo "‚úÖ Deployment completed!"
            echo "üîé Container status:"
            docker-compose ps
            
            # Check if Caddy config exists and display information
            if [ -f "docs/caddy-config.md" ]; then
              echo "‚ö†Ô∏è IMPORTANT: Update your Caddy configuration with:"
              echo "üìÅ $(pwd)/docs/caddy-config.md"
            fi
            
            # Verify deployed version
            echo "üìã Deployed version information:"
            git log -n 1 --pretty=format:"Commit: %h%nAuthor: %an%nDate: %ad%nMessage: %s"
          EOL
      - name: Restart Container to Apply Certificate Changes
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            set -ex
            
            # Define variables
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            
            cd "$DEPLOY_PATH"
            
            echo "üîÑ Restarting container to apply certificate changes..."
            docker-compose restart 3x-ui
            
            echo "‚è±Ô∏è Waiting for container to start..."
            sleep 5
            
            echo "üìã Container status:"
            docker-compose ps
            
            echo "üìã Container logs (last 20 lines):"
            docker-compose logs --tail=20 3x-ui
          EOL
      - name: Verify deployment
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            set -ex  # Enable verbose logging and exit on error
            
            # Define deploy path
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            
            echo "Verifying deployment in $DEPLOY_PATH"
            cd "$DEPLOY_PATH" || {
              echo "ERROR: Unable to cd to $DEPLOY_PATH"
              exit 1
            }
            
            echo "Directory structure:"
            find . -type d -maxdepth 2 | sort
            
            echo "Critical files:"
            ls -la docker-compose.yml .env* db/ 2>/dev/null || echo "Some files may be missing"
            
            echo "Container status:"
            docker-compose ps
            
            echo "Running containers:"
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            
            echo "Container logs (last 10 lines):"
            docker-compose logs --tail=10
            
            echo "Checking if 3x-ui container is running:"
            if docker ps | grep -q '3x-ui'; then
              echo "‚úÖ 3x-ui container is running"
            else
              echo "‚ùå 3x-ui container is NOT running!"
              echo "Container details:"
              docker ps -a | grep 3x-ui || echo "No container found"
              echo "Container logs:"
              docker-compose logs 3x-ui
              exit 1
            fi
            
            echo "‚úÖ Deployment verification completed successfully"
          EOL

  verify:
    name: ‚úÖ Verify Deployment
    needs: deploy
    runs-on: ubuntu-latest
    steps:
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      - name: Add to known hosts
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
      - name: Verify deployment
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            set -ex  # Enable verbose logging and exit on error
            
            # Define deploy path
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            
            echo "Verifying deployment in $DEPLOY_PATH"
            cd "$DEPLOY_PATH" || {
              echo "ERROR: Unable to cd to $DEPLOY_PATH"
              exit 1
            }
            
            echo "Directory structure:"
            find . -type d -maxdepth 2 | sort
            
            echo "Critical files:"
            ls -la docker-compose.yml .env* db/ 2>/dev/null || echo "Some files may be missing"
            
            echo "Container status:"
            docker-compose ps
            
            echo "Running containers:"
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            
            echo "Container logs (last 10 lines):"
            docker-compose logs --tail=10
            
            echo "Checking if 3x-ui container is running:"
            if docker ps | grep -q '3x-ui'; then
              echo "‚úÖ 3x-ui container is running"
            else
              echo "‚ùå 3x-ui container is NOT running!"
              echo "Container details:"
              docker ps -a | grep 3x-ui || echo "No container found"
              echo "Container logs:"
              docker-compose logs 3x-ui
              exit 1
            fi
            
            echo "‚úÖ Deployment verification completed successfully"
          EOL

  logs:
    name: üìä Collect Logs
    needs: [deploy, verify]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      - name: Add to known hosts
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
      - name: Ensure logs directory is not empty
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} '
            set -e
            cd ${{ secrets.DEPLOY_PATH }}
            mkdir -p logs
            sudo chown $USER:$USER logs
            sudo chmod 777 logs
            if [ -z "$(ls -A logs)" ]; then
              echo "No logs found, creating dummy.log"
              sudo touch logs/dummy.log
              sudo chmod 666 logs/dummy.log
              echo "No logs available." | sudo tee logs/dummy.log
            fi
            echo "Contents of logs directory after ensuring dummy.log:"
            ls -l logs
            if [ -z "$(ls -A logs)" ]; then
              echo "ERROR: logs directory is still empty after attempting to create dummy.log"
              exit 1
            else
              echo "Logs directory is ready for SCP."
            fi
          '
      - name: Copy local dummy.log to server if needed
        run: |
          echo "No logs available." > dummy.log
          scp -o StrictHostKeyChecking=no dummy.log ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:${{ secrets.DEPLOY_PATH }}/logs/dummy.log
      - name: "Debug: List logs directory on server before SCP"
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} '
            cd ${{ secrets.DEPLOY_PATH }}
            echo "Listing logs directory before SCP:"
            ls -l logs
          '
      - name: Create local workflow_logs directory
        run: |
          mkdir -p workflow_logs
          echo "No logs available. Created by workflow." > workflow_logs/dummy.log
          echo "Created local workflow_logs directory with dummy file for artifact upload"
      - name: Download logs from server
        run: |
          # Create a directory for logs
          mkdir -p downloaded_logs
          # Try to download logs using scp, but don't fail if it doesn't work
          scp -o StrictHostKeyChecking=no -r ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:${{ secrets.DEPLOY_PATH }}/logs/* downloaded_logs/ || true
          # Check if we got any logs, if not create a dummy file
          if [ -z "$(ls -A downloaded_logs)" ]; then
            echo "No logs were downloaded, creating a dummy log file"
            echo "No logs were available on the server at the time of collection." > downloaded_logs/empty_logs.txt
          fi
          # Copy all downloaded logs to the workflow_logs directory
          cp -r downloaded_logs/* workflow_logs/ || true
          # List what we have
          echo "Contents of workflow_logs directory:"
          ls -la workflow_logs/
      - name: Archive logs
        uses: actions/upload-artifact@v4
        with:
          name: deployment-logs
          path: workflow_logs/
          retention-days: 7

  summary:
    name: üéâ Deployment Summary
    needs: [debug_info, validate, setup, deploy, verify, logs, cert_fix]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Generate Summary
        run: |
          echo "# 3x-ui VPN Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "‚úÖ **Debug Info**: See debug_info job" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **Configuration Validation**: See validate job" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **SSH Setup**: See setup job" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **Deployment**: See deploy job" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **Verification**: See verify job" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **Logs**: See logs job" >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Access Information" >> $GITHUB_STEP_SUMMARY
          echo "üîó **Admin Panel**: https://${{ secrets.VPN_DOMAIN }}/BXv8SI7gBe/" >> $GITHUB_STEP_SUMMARY
      - name: Output Result
        run: |
          echo "‚úÖ 3x-ui VPN deployment workflow completed."