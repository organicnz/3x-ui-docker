permissions:
  contents: read

name: 3x-ui VPN Service Management

on:
  workflow_dispatch:
  push:
    branches:
      - main
    paths-ignore:
      - README.md
      - .gitignore
      - logs/**
      - workflow_logs/**
  schedule:
    - cron: 0 2 * * *  # Run daily at 2 AM UTC for backups

jobs:
  debug_info:
    name: üêõ Debug Workflow Info
    runs-on: ubuntu-latest
    steps:
      - name: Display Trigger Info
        env:
          GH_EVENT_NAME: ${{ github.event_name }}
          GH_REF_NAME: ${{ github.ref_name }}
          GH_BASE_REF: ${{ github.base_ref }}
          GH_REF_TYPE: ${{ github.ref_type }}
          GH_REPOSITORY: ${{ github.repository }}
          GH_RUN_ID: ${{ github.run_id }}
        run: |
          echo "Workflow triggered by: $GH_EVENT_NAME"
          echo "Ref name: $GH_REF_NAME"
          echo "Base ref: $GH_BASE_REF"
          echo "Ref type: $GH_REF_TYPE"
          echo "Repository: $GH_REPOSITORY"
          echo "Run ID: $GH_RUN_ID"
          echo "Auto-deploy mode: enabled"

  cert_fix:
    name: üöë Emergency Certificate Fix
    runs-on: ubuntu-latest
    if: false  # Disabled by default, use separate workflow for cert fixes
    steps:
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      - name: Add to known hosts
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
      - name: Fix SSL Certificates
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            set -ex  # Enable verbose logging and exit on errors
            
            # Define variables
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            DOMAIN="${{ secrets.VPN_DOMAIN }}"
            CERT_DIR="$DEPLOY_PATH/cert/$DOMAIN"
            
            echo "üîç Checking current container status..."
            cd "$DEPLOY_PATH"
            docker-compose ps
            
            echo "üìÅ Creating certificate directory..."
            mkdir -p "$CERT_DIR"
            
            echo "üîë Creating self-signed certificates..."
            openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
              -keyout "$CERT_DIR/privkey.pem" \
              -out "$CERT_DIR/fullchain.pem" \
              -subj "/CN=$DOMAIN/O=3x-ui/C=US" \
              -addext "subjectAltName=DNS:$DOMAIN"
            
            echo "üîí Setting permissions..."
            chmod 644 "$CERT_DIR/fullchain.pem"
            chmod 600 "$CERT_DIR/privkey.pem"
            
            echo "üîÑ Restarting 3x-ui container..."
            docker-compose restart 3x-ui
            
            echo "‚úÖ Certificate fix complete!"
            echo "üìã Container status after fix:"
            docker-compose ps
            
            echo "üìã Certificate details:"
            openssl x509 -noout -text -in "$CERT_DIR/fullchain.pem" | grep -E "Subject:|Issuer:|Not Before:|Not After :|DNS:"
            
            echo "üìã Container logs (last 10 lines):"
            sleep 5  # Give the container time to start
            docker-compose logs --tail=10 3x-ui
          EOL
      - name: Add to workflow summary
        run: |
          echo "# üöë Certificate Emergency Fix" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Emergency certificate fix was applied to ensure the service has valid SSL certificates." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "For production use, consider running the full workflow to acquire proper Let's Encrypt certificates." >> $GITHUB_STEP_SUMMARY

  validate:
    name: üîç Validate Configuration
    runs-on: ubuntu-latest
    needs: debug_info
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Validate Docker Compose
        run: |
          if [ ! -f docker-compose.yml ]; then
            echo "ERROR: docker-compose.yml not found!"
            exit 1
          fi
          cat docker-compose.yml | python3 -c "import sys, yaml; yaml.safe_load(sys.stdin)" && echo "‚úÖ Valid YAML"
          grep -q "3x-ui:" docker-compose.yml && echo "‚úÖ 3x-ui service found"
          grep -q "54321:54321" docker-compose.yml && echo "‚úÖ Admin panel port (54321) configured"

  setup:
    name: üöÄ Setup Server
    needs: validate
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      - name: Add to known hosts
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
      - name: Check SSH connectivity
        run: |
          ssh -o BatchMode=yes -o ConnectTimeout=10 ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            echo '‚úÖ SSH connection successful'
          EOL
      - name: Initialize Git repository on server
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            set -ex  # Enable verbose logging and exit on error
            
            # Define variables
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            REPO_URL="https://github.com/${{ github.repository }}.git"
            
            echo "Current working directory: $(pwd)"
            echo "Checking if $DEPLOY_PATH exists..."
            
            # Colors for better output readability
            RED='\033[0;31m'
            GREEN='\033[0;32m'
            YELLOW='\033[1;33m'
            NC='\033[0m' # No Color
            
            echo -e "${GREEN}==== 3x-ui VPN Git Repository Fix ====${NC}"
            
            # Ensure deploy path exists
            if [ ! -d "$DEPLOY_PATH" ]; then
              echo -e "${YELLOW}Creating directory $DEPLOY_PATH${NC}"
              mkdir -p "$DEPLOY_PATH"
            fi
            
            # Backup important data first
            echo -e "${YELLOW}Backing up important data${NC}"
            BACKUP_DIR="/tmp/3x-ui-backup-$(date +%s)"
            mkdir -p "$BACKUP_DIR"
            
            if [ -d "$DEPLOY_PATH" ]; then
              cd "$DEPLOY_PATH"
              
              # Backup essential files
              if [ -f ".env" ]; then
                cp .env "$BACKUP_DIR/"
                echo -e "${GREEN}Backed up .env file${NC}"
              fi
              
              if [ -d "db" ]; then
                mkdir -p "$BACKUP_DIR/db"
                cp -r db/* "$BACKUP_DIR/db/" 2>/dev/null || true
                echo -e "${GREEN}Backed up database files${NC}"
              fi
              
              if [ -d "logs" ]; then
                mkdir -p "$BACKUP_DIR/logs"
                cp -r logs/* "$BACKUP_DIR/logs/" 2>/dev/null || true
                echo -e "${GREEN}Backed up log files${NC}"
              fi
              
              if [ -d "cert" ]; then
                mkdir -p "$BACKUP_DIR/cert"
                cp -r cert/* "$BACKUP_DIR/cert/" 2>/dev/null || true
                echo -e "${GREEN}Backed up certificate files${NC}"
              fi
            fi
            
            # Check if it's a functioning git repository
            cd "$DEPLOY_PATH" || {
              echo -e "${RED}Failed to cd to $DEPLOY_PATH, creating it${NC}"
              mkdir -p "$DEPLOY_PATH"
              cd "$DEPLOY_PATH"
            }
            
            # Check if .git directory exists and is working
            if [ -d ".git" ]; then
              echo -e "${GREEN}Git repository exists, checking if it's working...${NC}"
              if ! git status &> /dev/null; then
                echo -e "${RED}Git repository is broken, recreating...${NC}"
                cd ..
                mv "$DEPLOY_PATH" "${DEPLOY_PATH}_old_$(date +%s)"
                git clone "$REPO_URL" "$DEPLOY_PATH"
                cd "$DEPLOY_PATH"
              else
                echo -e "${GREEN}Git repository is working correctly${NC}"
                # Fetch and reset to ensure clean state
                git fetch --all
                git reset --hard origin/main
              fi
            else
              echo -e "${YELLOW}No git repository found, initializing...${NC}"
              # Check if the directory is empty
              if [ "$(ls -A | grep -v '.git')" ]; then
                echo -e "${YELLOW}Directory not empty, backing up and initializing git${NC}"
                # Move everything to a temp folder except .git
                TEMP_DIR="/tmp/3x-ui-content-$(date +%s)"
                mkdir -p "$TEMP_DIR"
                find . -mindepth 1 -maxdepth 1 -not -path "./\.git*" -exec mv {} "$TEMP_DIR/" \;
                
                # Initialize git
                git init
                git remote add origin "$REPO_URL"
                git fetch --all
                git reset --hard origin/main
                
                # Move back important files
                if [ -d "$TEMP_DIR" ]; then
                  # Only move back .env, db/, logs/, and cert/
                  if [ -f "$TEMP_DIR/.env" ]; then
                    cp "$TEMP_DIR/.env" .
                  fi
                  
                  for dir in db logs cert; do
                    if [ -d "$TEMP_DIR/$dir" ]; then
                      mkdir -p "$dir"
                      cp -r "$TEMP_DIR/$dir/"* "$dir/" 2>/dev/null || true
                    fi
                  done
                fi
              else
                echo -e "${YELLOW}Directory empty, cloning repository${NC}"
                git init
                git remote add origin "$REPO_URL"
                git fetch --all
                git reset --hard origin/main
              fi
            fi
            
            # Restore from backup if needed
            if [ -d "$BACKUP_DIR" ]; then
              echo -e "${YELLOW}Restoring from backup...${NC}"
              
              # Restore .env
              if [ -f "$BACKUP_DIR/.env" ]; then
                cp "$BACKUP_DIR/.env" .env
                echo -e "${GREEN}Restored .env file${NC}"
              fi
              
              # Restore database
              if [ -d "$BACKUP_DIR/db" ] && [ "$(ls -A "$BACKUP_DIR/db" 2>/dev/null)" ]; then
                mkdir -p db
                cp -r "$BACKUP_DIR/db/"* db/ 2>/dev/null || true
                echo -e "${GREEN}Restored database files${NC}"
              fi
              
              # Restore logs
              if [ -d "$BACKUP_DIR/logs" ] && [ "$(ls -A "$BACKUP_DIR/logs" 2>/dev/null)" ]; then
                mkdir -p logs
                cp -r "$BACKUP_DIR/logs/"* logs/ 2>/dev/null || true
                echo -e "${GREEN}Restored log files${NC}"
              fi
              
              # Restore certificates
              if [ -d "$BACKUP_DIR/cert" ] && [ "$(ls -A "$BACKUP_DIR/cert" 2>/dev/null)" ]; then
                mkdir -p cert
                cp -r "$BACKUP_DIR/cert/"* cert/ 2>/dev/null || true
                echo -e "${GREEN}Restored certificate files${NC}"
              fi
            fi
            
            # Ensure the necessary directories exist
            echo -e "${YELLOW}Ensuring required directories exist...${NC}"
            mkdir -p db cert logs cert/service.foodshare.club
            
            # Ensure database file exists
            if [ ! -f "db/x-ui.db" ]; then
              echo -e "${YELLOW}Creating db/x-ui.db placeholder...${NC}"
              touch db/x-ui.db
            fi
            
            # Ensure proper permissions
            echo -e "${YELLOW}Setting correct permissions...${NC}"
            chmod -R 755 .
            chmod -R 777 logs
            chmod 644 db/x-ui.db
            
            # Verify repository setup
            echo -e "${GREEN}Repository has been fixed successfully!${NC}"
            echo "Current directory: $(pwd)"
            echo "Repository content:"
            ls -la
            echo "Git status:"
            git status
            echo "Latest commits:"
            git log -n 3 --oneline || echo "No commits yet"
          EOL
      - name: Install Docker if not installed
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
          if ! command -v docker &> /dev/null; then
            echo "Installing Docker..."
            curl -fsSL https://get.docker.com -o get-docker.sh
            sudo sh get-docker.sh
            sudo usermod -aG docker $USER
          else
            echo "Docker already installed."
          fi
          if ! command -v docker-compose &> /dev/null; then
            echo "Installing Docker Compose..."
            sudo curl -L "https://github.com/docker/compose/releases/download/v2.15.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
          else
            echo "Docker Compose already installed."
          fi
          EOL

  deploy:
    name: üö¢ Deploy VPN Service
    needs: [setup]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      - name: Add to known hosts
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
      - name: Deploy from Git
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            set -ex  # Enable verbose logging and exit on error
            
            # Define variables
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            REPO_URL="https://github.com/${{ github.repository }}.git"
            DEPLOY_BRANCH="main"
            REPO_ROOT=$(dirname "$DEPLOY_PATH")
            REPO_DIR=$(basename "$DEPLOY_PATH")
            
            # Colors for output
            RED='\033[0;31m'
            GREEN='\033[0;32m'
            YELLOW='\033[1;33m'
            NC='\033[0m' # No Color
            
            echo -e "${GREEN}==== Deploying 3x-ui VPN Service ====${NC}"
            
            # Check current state 
            echo -e "${YELLOW}Checking repository at $DEPLOY_PATH${NC}"
            if [ -d "$DEPLOY_PATH" ]; then
              cd "$DEPLOY_PATH"
              
              # Count files to see if repository has content
              FILE_COUNT=$(find . -type f | wc -l)
              if [ "$FILE_COUNT" -lt 5 ]; then
                echo -e "${RED}Repository has minimal files ($FILE_COUNT found). Recreating...${NC}"
                NEEDS_RECREATE=true
              else
                echo -e "${GREEN}Repository has $FILE_COUNT files.${NC}"
                # Check if docker-compose.yml exists
                if [ ! -f "docker-compose.yml" ]; then
                  echo -e "${RED}Missing docker-compose.yml. Recreating repository...${NC}"
                  NEEDS_RECREATE=true
                else
                  echo -e "${GREEN}docker-compose.yml exists.${NC}"
                  NEEDS_RECREATE=false
                fi
              fi
            else
              echo -e "${YELLOW}Repository directory does not exist. Creating...${NC}"
              mkdir -p "$DEPLOY_PATH"
              NEEDS_RECREATE=true
            fi
            
            # Backup important data first
            echo -e "${YELLOW}Backing up important data${NC}"
            BACKUP_DIR="/tmp/3x-ui-backup-$(date +%s)"
            mkdir -p "$BACKUP_DIR"
            
            if [ -d "$DEPLOY_PATH" ]; then
              cd "$DEPLOY_PATH"
              
              # Backup essential files
              if [ -f ".env" ]; then
                cp .env "$BACKUP_DIR/"
                echo -e "${GREEN}Backed up .env file${NC}"
              fi
              
              if [ -d "db" ]; then
                mkdir -p "$BACKUP_DIR/db"
                cp -r db/* "$BACKUP_DIR/db/" 2>/dev/null || true
                echo -e "${GREEN}Backed up database files${NC}"
              fi
              
              if [ -d "logs" ]; then
                mkdir -p "$BACKUP_DIR/logs"
                cp -r logs/* "$BACKUP_DIR/logs/" 2>/dev/null || true
                echo -e "${GREEN}Backed up log files${NC}"
              fi
              
              if [ -d "cert" ]; then
                mkdir -p "$BACKUP_DIR/cert"
                cp -r cert/* "$BACKUP_DIR/cert/" 2>/dev/null || true
                echo -e "${GREEN}Backed up certificate files${NC}"
              fi
            fi
            
            # Recreate repository if needed
            if [ "$NEEDS_RECREATE" = true ]; then
              # Go to parent directory
              cd "$REPO_ROOT"
              
              # Rename old directory if it exists
              if [ -d "$REPO_DIR" ]; then
                TIMESTAMP=$(date +%s)
                mv "$REPO_DIR" "${REPO_DIR}_old_${TIMESTAMP}"
                echo -e "${YELLOW}Renamed old directory to ${REPO_DIR}_old_${TIMESTAMP}${NC}"
              fi
              
              # Clone fresh repository
              echo -e "${YELLOW}Cloning fresh repository from $REPO_URL${NC}"
              git clone -b "$DEPLOY_BRANCH" "$REPO_URL" "$REPO_DIR"
              
              # Enter repository
              cd "$REPO_DIR"
              
              # Verify clone was successful
              if [ ! -f "docker-compose.yml" ]; then
                echo -e "${RED}ERROR: docker-compose.yml not found after cloning. Check repository.${NC}"
                ls -la
                exit 1
              else
                echo -e "${GREEN}Repository cloned successfully with docker-compose.yml present.${NC}"
              fi
            else
              # If we don't need to recreate, just pull latest changes
              cd "$DEPLOY_PATH"
              echo -e "${YELLOW}Pulling latest changes...${NC}"
              git pull origin "$DEPLOY_BRANCH"
            fi
            
            # Make sure we're in the repository
            cd "$DEPLOY_PATH"
            
            # Restore data from backup
            if [ -d "$BACKUP_DIR" ]; then
              echo -e "${YELLOW}Restoring from backup...${NC}"
              
              # Restore .env
              if [ -f "$BACKUP_DIR/.env" ]; then
                cp "$BACKUP_DIR/.env" .env
                echo -e "${GREEN}Restored .env file${NC}"
              fi
              
              # Restore database
              if [ -d "$BACKUP_DIR/db" ] && [ "$(ls -A "$BACKUP_DIR/db" 2>/dev/null)" ]; then
                mkdir -p db
                cp -r "$BACKUP_DIR/db/"* db/ 2>/dev/null || true
                echo -e "${GREEN}Restored database files${NC}"
              fi
              
              # Restore logs
              if [ -d "$BACKUP_DIR/logs" ] && [ "$(ls -A "$BACKUP_DIR/logs" 2>/dev/null)" ]; then
                mkdir -p logs
                cp -r "$BACKUP_DIR/logs/"* logs/ 2>/dev/null || true
                echo -e "${GREEN}Restored log files${NC}"
              fi
              
              # Restore certificates
              if [ -d "$BACKUP_DIR/cert" ] && [ "$(ls -A "$BACKUP_DIR/cert" 2>/dev/null)" ]; then
                mkdir -p cert
                cp -r "$BACKUP_DIR/cert/"* cert/ 2>/dev/null || true
                echo -e "${GREEN}Restored certificate files${NC}"
              fi
            fi
            
            # Create default .env if it doesn't exist
            if [ ! -f ".env" ]; then
              if [ -f ".env.example" ]; then
                cp .env.example .env
                echo "üìÑ Created .env file from template"
              else
                touch .env
                echo "üìÑ Created empty .env file"
              fi
            fi
            
            # Ensure required directories exist
            echo "üìÅ Ensuring required directories exist"
            mkdir -p db cert logs cert/service.foodshare.club docs
            
            # Ensure db/x-ui.db exists and is a file
            if [ -d "db/x-ui.db" ]; then
              echo "‚ö†Ô∏è db/x-ui.db is a directory, fixing..."
              rm -rf db/x-ui.db
              touch db/x-ui.db
              echo "‚úÖ Fixed db/x-ui.db"
            elif [ ! -f "db/x-ui.db" ]; then
              echo "üìÑ Creating db/x-ui.db placeholder"
              touch db/x-ui.db
            fi
            
            # Set up Docker networks
            echo "üåê Setting up Docker networks"
            docker network create web 2>/dev/null || true
            docker network create no-zero-trust-cloudflared 2>/dev/null || true
            
            # Deploy containers
            echo "üöÄ Deploying containers"
            docker-compose pull
            docker-compose down
            docker-compose up -d
            
            echo "‚úÖ Deployment completed!"
            echo "üîé Container status:"
            docker-compose ps
            
            # Check if Caddy config exists and display information
            if [ -f "docs/caddy-config.md" ]; then
              echo "‚ö†Ô∏è IMPORTANT: Update your Caddy configuration with:"
              echo "üìÅ $(pwd)/docs/caddy-config.md"
            fi
            
            # Verify deployed version
            echo "üìã Deployed version information:"
            git log -n 1 --pretty=format:"Commit: %h%nAuthor: %an%nDate: %ad%nMessage: %s"
          EOL
      - name: Verify deployment
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            set -ex  # Enable verbose logging and exit on error
            
            # Define deploy path
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            
            echo "Verifying deployment in $DEPLOY_PATH"
            cd "$DEPLOY_PATH" || {
              echo "ERROR: Unable to cd to $DEPLOY_PATH"
              exit 1
            }
            
            echo "Directory structure:"
            find . -type d -maxdepth 2 | sort
            
            echo "Critical files:"
            ls -la docker-compose.yml .env* db/ 2>/dev/null || echo "Some files may be missing"
            
            echo "Container status:"
            docker-compose ps
            
            echo "Running containers:"
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            
            echo "Container logs (last 10 lines):"
            docker-compose logs --tail=10
            
            echo "Checking if 3x-ui container is running:"
            if docker ps | grep -q '3x-ui'; then
              echo "‚úÖ 3x-ui container is running"
            else
              echo "‚ùå 3x-ui container is NOT running!"
              echo "Container details:"
              docker ps -a | grep 3x-ui || echo "No container found"
              echo "Container logs:"
              docker-compose logs 3x-ui
              exit 1
            fi
            
            echo "‚úÖ Deployment verification completed successfully"
          EOL

  verify:
    name: ‚úÖ Verify Deployment
    needs: deploy
    runs-on: ubuntu-latest
    steps:
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      - name: Add to known hosts
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
      - name: Verify deployment
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOL'
            set -ex  # Enable verbose logging and exit on error
            
            # Define deploy path
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            
            echo "Verifying deployment in $DEPLOY_PATH"
            cd "$DEPLOY_PATH" || {
              echo "ERROR: Unable to cd to $DEPLOY_PATH"
              exit 1
            }
            
            echo "Directory structure:"
            find . -type d -maxdepth 2 | sort
            
            echo "Critical files:"
            ls -la docker-compose.yml .env* db/ 2>/dev/null || echo "Some files may be missing"
            
            echo "Container status:"
            docker-compose ps
            
            echo "Running containers:"
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            
            echo "Container logs (last 10 lines):"
            docker-compose logs --tail=10
            
            echo "Checking if 3x-ui container is running:"
            if docker ps | grep -q '3x-ui'; then
              echo "‚úÖ 3x-ui container is running"
            else
              echo "‚ùå 3x-ui container is NOT running!"
              echo "Container details:"
              docker ps -a | grep 3x-ui || echo "No container found"
              echo "Container logs:"
              docker-compose logs 3x-ui
              exit 1
            fi
            
            echo "‚úÖ Deployment verification completed successfully"
          EOL

  logs:
    name: üìä Collect Logs
    needs: [deploy, verify]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      - name: Add to known hosts
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
      - name: Ensure logs directory is not empty
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} '
            set -e
            cd ${{ secrets.DEPLOY_PATH }}
            mkdir -p logs
            sudo chown $USER:$USER logs
            sudo chmod 777 logs
            if [ -z "$(ls -A logs)" ]; then
              echo "No logs found, creating dummy.log"
              sudo touch logs/dummy.log
              sudo chmod 666 logs/dummy.log
              echo "No logs available." | sudo tee logs/dummy.log
            fi
            echo "Contents of logs directory after ensuring dummy.log:"
            ls -l logs
            if [ -z "$(ls -A logs)" ]; then
              echo "ERROR: logs directory is still empty after attempting to create dummy.log"
              exit 1
            else
              echo "Logs directory is ready for SCP."
            fi
          '
      - name: Copy local dummy.log to server if needed
        run: |
          echo "No logs available." > dummy.log
          scp -o StrictHostKeyChecking=no dummy.log ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:${{ secrets.DEPLOY_PATH }}/logs/dummy.log
      - name: "Debug: List logs directory on server before SCP"
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} '
            cd ${{ secrets.DEPLOY_PATH }}
            echo "Listing logs directory before SCP:"
            ls -l logs
          '
      - name: Create local workflow_logs directory
        run: |
          mkdir -p workflow_logs
          echo "No logs available. Created by workflow." > workflow_logs/dummy.log
          echo "Created local workflow_logs directory with dummy file for artifact upload"
      - name: Download logs from server
        run: |
          # Create a directory for logs
          mkdir -p downloaded_logs
          # Try to download logs using scp, but don't fail if it doesn't work
          scp -o StrictHostKeyChecking=no -r ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:${{ secrets.DEPLOY_PATH }}/logs/* downloaded_logs/ || true
          # Check if we got any logs, if not create a dummy file
          if [ -z "$(ls -A downloaded_logs)" ]; then
            echo "No logs were downloaded, creating a dummy log file"
            echo "No logs were available on the server at the time of collection." > downloaded_logs/empty_logs.txt
          fi
          # Copy all downloaded logs to the workflow_logs directory
          cp -r downloaded_logs/* workflow_logs/ || true
          # List what we have
          echo "Contents of workflow_logs directory:"
          ls -la workflow_logs/
      - name: Archive logs
        uses: actions/upload-artifact@v4
        with:
          name: deployment-logs
          path: workflow_logs/
          retention-days: 7

  summary:
    name: üéâ Deployment Summary
    needs: [debug_info, validate, setup, deploy, verify, logs, cert_fix]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Generate Summary
        run: |
          echo "# 3x-ui VPN Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "‚úÖ **Debug Info**: See debug_info job" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **Configuration Validation**: See validate job" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **SSH Setup**: See setup job" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **Deployment**: See deploy job" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **Verification**: See verify job" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **Logs**: See logs job" >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Access Information" >> $GITHUB_STEP_SUMMARY
          echo "üîó **Admin Panel**: https://${{ secrets.VPN_DOMAIN }}/BXv8SI7gBe/" >> $GITHUB_STEP_SUMMARY
      - name: Output Result
        run: |
          echo "‚úÖ 3x-ui VPN deployment workflow completed."