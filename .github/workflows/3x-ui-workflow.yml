name: 3x-ui VPN Service

on:
  push:
    branches: [main]
    paths-ignore:
      - '**.md'
      - '.gitignore'
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      action:
        description: Action to perform
        required: true
        default: deploy
        type: choice
        options:
          - setup
          - deploy

# Define default permissions
permissions:
  contents: read
  actions: read

# Global environment variables
env:
  DEFAULT_DOMAIN: service.foodshare.club
  DEFAULT_EMAIL: admin@example.com

jobs:
  # Validate configuration (runs on all events)
  validate:
    name: üß™ Validate Configuration
    runs-on: ubuntu-latest
    outputs:
      action: ${{ steps.set_action.outputs.action }}
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        
      - name: üîç Determine action
        id: set_action
        run: |
          # Default action based on event type
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ACTION="${{ github.event.inputs.action }}"
          elif [[ "${{ github.event_name }}" == "push" ]]; then
            ACTION="deploy"
          else
            ACTION="validate_only"  # PR events only validate
          fi
          echo "action=${ACTION}" >> $GITHUB_OUTPUT
          echo "Selected action: ${ACTION}"
        
      - name: üß∞ Validate Docker Compose
        run: |
          echo "Validating Docker Compose file syntax..."
          if [ ! -f docker-compose.yml ]; then
            echo "::error::docker-compose.yml not found!"
            exit 1
          fi
          
          # Validate YAML syntax
          cat docker-compose.yml | python -c "import sys, yaml; yaml.safe_load(sys.stdin)" && echo "‚úÖ Valid YAML" || (echo "‚ùå Invalid YAML" && exit 1)
          
          # Check required services and ports
          grep -q "3x-ui:" docker-compose.yml && echo "‚úÖ 3x-ui service found" || (echo "‚ùå 3x-ui service not found" && exit 1)
          grep -q "443:443" docker-compose.yml && echo "‚úÖ HTTPS port (443) configured" || (echo "‚ö†Ô∏è HTTPS port (443) might not be configured" && exit 1)
          grep -q "2053:2053" docker-compose.yml && echo "‚úÖ VPN Panel port (2053) configured" || (echo "‚ö†Ô∏è VPN Panel port (2053) might not be configured" && exit 1)
      
      - name: üß∞ Verify Docker image
        run: |
          echo "Testing Docker image pull..."
          docker pull ghcr.io/mhsanaei/3x-ui:latest
          echo "‚úÖ Docker image is available and can be pulled"
          docker inspect ghcr.io/mhsanaei/3x-ui:latest --format='{{.Config.Entrypoint}}'
          docker inspect ghcr.io/mhsanaei/3x-ui:latest --format='{{.Config.Cmd}}'

  # Comprehensive testing
  test:
    name: üî¨ Comprehensive Tests
    needs: validate
    if: needs.validate.outputs.action != 'setup'
    runs-on: ubuntu-latest
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
      
      - name: üß™ Setup test environment
        run: |
          echo "Setting up test environment..."
          mkdir -p ./logs ./cert ./test_results
          touch x-ui.db
          chmod 644 x-ui.db
      
      - name: üîé Test Docker image integrity
        run: |
          echo "Testing Docker image integrity..."
          # Pull the image
          docker pull ghcr.io/mhsanaei/3x-ui:latest
          
          # Extract image metadata for verification
          IMAGE_ID=$(docker images ghcr.io/mhsanaei/3x-ui:latest --format "{{.ID}}")
          echo "Image ID: $IMAGE_ID"
          
          # Check image size (ensure it's not suspiciously small or large)
          IMAGE_SIZE=$(docker images ghcr.io/mhsanaei/3x-ui:latest --format "{{.Size}}")
          echo "Image size: $IMAGE_SIZE"
          
          # Inspect image configuration
          echo "Checking image configuration..."
          docker inspect ghcr.io/mhsanaei/3x-ui:latest > ./test_results/image_config.json
          
          # Check for required labels
          echo "Verifying image labels..."
          LABEL_COUNT=$(docker inspect ghcr.io/mhsanaei/3x-ui:latest --format '{{len .Config.Labels}}')
          echo "Label count: $LABEL_COUNT"
          
          # Extract entrypoint and verify it exists
          ENTRYPOINT=$(docker inspect ghcr.io/mhsanaei/3x-ui:latest --format '{{json .Config.Entrypoint}}')
          echo "Entrypoint: $ENTRYPOINT"
          if [[ "$ENTRYPOINT" == "null" || "$ENTRYPOINT" == "[]" ]]; then
            echo "‚ö†Ô∏è Warning: No entrypoint defined"
          else
            echo "‚úÖ Entrypoint is properly defined"
          fi
          
          # Check exposed ports
          EXPOSED_PORTS=$(docker inspect ghcr.io/mhsanaei/3x-ui:latest --format '{{json .Config.ExposedPorts}}')
          echo "Exposed ports: $EXPOSED_PORTS"
          
          echo "‚úÖ Docker image integrity checks completed"
      
      - name: üõ°Ô∏è Security configuration test
        run: |
          echo "Testing security configuration..."
          
          # Check for unsafe configurations in docker-compose.yml
          echo "Checking docker-compose.yml for security issues..."
          grep -q "privileged: true" docker-compose.yml && echo "‚ùå Security issue: Container runs with privileged mode" || echo "‚úÖ Container does not use privileged mode"
          grep -q "network_mode: host" docker-compose.yml && echo "‚ö†Ô∏è Warning: Container uses host network mode" || echo "‚úÖ Container does not use host network mode"
          
          # Validate ports
          echo "Checking exposed ports..."
          ADMIN_PORT=$(grep -o "[0-9]\+:54321" docker-compose.yml | cut -d':' -f1)
          if [[ -z "$ADMIN_PORT" ]]; then
            echo "‚ö†Ô∏è Warning: Admin port binding format could not be determined"
          else
            if [[ "$ADMIN_PORT" == "0.0.0.0" || "$ADMIN_PORT" == "*" ]]; then
              echo "‚ö†Ô∏è Warning: Admin port (54321) is exposed to all interfaces"
            else
              echo "‚úÖ Admin port has restricted binding"
            fi
          fi
          
          # Check for volume mounts with sensitive paths
          echo "Checking volume mounts..."
          grep -q "/etc:" docker-compose.yml && echo "‚ö†Ô∏è Warning: Container mounts /etc directory" || echo "‚úÖ No sensitive /etc mount found"
          grep -q "/var:" docker-compose.yml && echo "‚ö†Ô∏è Warning: Container mounts /var directory" || echo "‚úÖ No sensitive /var mount found"
          
          echo "‚úÖ Security configuration tests completed"
      
      - name: üß™ Simulated deployment test
        run: |
          echo "Running simulated deployment test..."
          
          # Start the container with test configuration
          echo "Starting container for testing..."
          export DOCKER_COMPOSE_FILE="docker-compose.yml"
          docker-compose up -d
          
          # Wait for the container to initialize
          echo "Waiting for container to initialize..."
          sleep 30
          
          # Check if container is running
          CONTAINER_STATUS=$(docker ps --filter "name=3x-ui" --format "{{.Status}}")
          if [[ -z "$CONTAINER_STATUS" ]]; then
            echo "‚ùå Container failed to start"
            docker-compose logs > ./test_results/container_logs.txt
            exit 1
          else
            echo "‚úÖ Container is running: $CONTAINER_STATUS"
          fi
          
          # Check container health
          HEALTH_STATUS=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}no-healthcheck{{end}}' 3x-ui)
          echo "Health status: $HEALTH_STATUS"
          if [[ "$HEALTH_STATUS" == "unhealthy" ]]; then
            echo "‚ùå Container is unhealthy"
            docker-compose logs > ./test_results/container_logs.txt
            docker-compose down
            exit 1
          elif [[ "$HEALTH_STATUS" == "no-healthcheck" ]]; then
            echo "‚ö†Ô∏è Container does not have a health check"
          else
            echo "‚úÖ Container health is OK: $HEALTH_STATUS"
          fi
          
          # Check if the service is responding
          echo "Testing service endpoints..."
          curl -s -o /dev/null -w "Admin panel: HTTP %{http_code}\n" http://localhost:54321/login
          
          # Clean up
          echo "Cleaning up test environment..."
          docker-compose down
          
          echo "‚úÖ Simulated deployment test completed"
      
      - name: üìä Archive test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: ./test_results/
          retention-days: 5

  # Initial server setup
  setup:
    name: üöÄ Server Setup
    needs: validate
    if: needs.validate.outputs.action == 'setup'
    runs-on: ubuntu-latest
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
      
      - name: üîë Setup SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      
      - name: üîê Add known hosts
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
      
      - name: üõ†Ô∏è Configure server
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          script: |
            # Create directory structure
            echo "Creating deployment directories..."
            mkdir -p ${{ secrets.DEPLOY_PATH }}/{cert,logs,workflow_logs}
            chmod 755 ${{ secrets.DEPLOY_PATH }}
            chmod 700 ${{ secrets.DEPLOY_PATH }}/cert
            
            # Install Docker if needed
            if ! command -v docker &> /dev/null; then
              echo "Installing Docker..."
              curl -fsSL https://get.docker.com -o get-docker.sh
              sh get-docker.sh
            fi
            
            # Install Docker Compose if needed
            if ! command -v docker-compose &> /dev/null; then
              echo "Installing Docker Compose..."
              apt-get update
              apt-get install -y docker-compose
            fi
            
            # Setup log rotation
            cat > /tmp/x-ui-logrotate << 'EOL'
            ${{ secrets.DEPLOY_PATH }}/logs/*.log {
                daily
                missingok
                rotate 7
                compress
                delaycompress
                notifempty
                create
            }
            EOL
            sudo mv /tmp/x-ui-logrotate /etc/logrotate.d/x-ui
            
            # Create SSL directories
            mkdir -p ${{ secrets.DEPLOY_PATH }}/cert/letsencrypt
            
            # Log setup completion
            TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
            echo "Server setup completed at ${TIMESTAMP}" > "${{ secrets.DEPLOY_PATH }}/workflow_logs/setup_${TIMESTAMP}.log"
            echo "‚úÖ Server configuration complete"
      
      - name: üìã Verify installation
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          script: |
            echo "Verifying installation..."
            ls -la ${{ secrets.DEPLOY_PATH }}
            docker --version
            docker-compose --version

  # Deploy application (includes SSL setup)
  deploy:
    name: üö¢ Deploy Application
    needs: [validate, test]
    if: needs.validate.outputs.action == 'deploy'
    runs-on: ubuntu-latest
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
      
      - name: üîë Setup SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      
      - name: üîê Add known hosts
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
      
      - name: üîó Verify SSH connection
        run: |
          echo "Testing SSH connection..."
          ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "echo '‚úÖ SSH connection successful'" || (echo '‚ùå SSH connection failed' && exit 1)
      
      - name: üîí Setup SSL Certificate
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          script: |
            cd ${{ secrets.DEPLOY_PATH }}
            
            # Setup variables
            DOMAIN="${{ secrets.VPN_DOMAIN || env.DEFAULT_DOMAIN }}"
            ADMIN_EMAIL="${{ secrets.ADMIN_EMAIL || env.DEFAULT_EMAIL }}"
            TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
            
            # Create log file
            DEPLOY_LOG="${{ secrets.DEPLOY_PATH }}/workflow_logs/deploy_${TIMESTAMP}.log"
            echo "Deployment started at $(date)" > $DEPLOY_LOG
            echo "Domain: ${DOMAIN}" >> $DEPLOY_LOG
            
            # Install certbot if needed
            if ! command -v certbot &> /dev/null; then
              echo "Installing certbot..." >> $DEPLOY_LOG
              apt-get update
              apt-get install -y certbot
            fi
            
            # Stop any running containers
            echo "Stopping any running containers..." >> $DEPLOY_LOG
            docker-compose down >> $DEPLOY_LOG 2>&1 || true
            
            # Generate SSL certificate if needed
            if [ ! -f "${{ secrets.DEPLOY_PATH }}/cert/fullchain.pem" ]; then
              echo "Generating SSL certificate for ${DOMAIN}..." >> $DEPLOY_LOG
              certbot certonly --standalone --preferred-challenges http --agree-tos -n \
                -d ${DOMAIN} -m ${ADMIN_EMAIL} \
                --cert-path=${{ secrets.DEPLOY_PATH }}/cert/cert.pem \
                --fullchain-path=${{ secrets.DEPLOY_PATH }}/cert/fullchain.pem \
                --chain-path=${{ secrets.DEPLOY_PATH }}/cert/chain.pem \
                --key-path=${{ secrets.DEPLOY_PATH }}/cert/privkey.pem \
                --config-dir=${{ secrets.DEPLOY_PATH }}/cert/letsencrypt \
                --work-dir=${{ secrets.DEPLOY_PATH }}/cert/letsencrypt \
                --logs-dir=${{ secrets.DEPLOY_PATH }}/logs/letsencrypt
            else
              echo "SSL certificate already exists, checking expiry..." >> $DEPLOY_LOG
              CERT_EXPIRY=$(openssl x509 -enddate -noout -in "${{ secrets.DEPLOY_PATH }}/cert/fullchain.pem" | cut -d= -f2)
              echo "Certificate expires on: ${CERT_EXPIRY}" >> $DEPLOY_LOG
            fi
            
            # Set proper permissions
            chmod 600 ${{ secrets.DEPLOY_PATH }}/cert/*.pem
            
            # Create .env file
            echo "Setting up environment file..." >> $DEPLOY_LOG
            cat > .env << EOL
            VPN_DOMAIN=${DOMAIN}
            ADMIN_EMAIL=${ADMIN_EMAIL}
            EOL
            
            # Pull latest image and start container
            echo "Pulling latest Docker image..." >> $DEPLOY_LOG
            docker-compose pull >> $DEPLOY_LOG 2>&1
            
            echo "Starting container..." >> $DEPLOY_LOG
            docker-compose up -d >> $DEPLOY_LOG 2>&1
            
            # Log container status
            echo "Container status:" >> $DEPLOY_LOG
            docker-compose ps >> $DEPLOY_LOG 2>&1
            docker-compose logs --tail=20 >> $DEPLOY_LOG 2>&1
            
            echo "Deployment completed at $(date)" >> $DEPLOY_LOG
            ln -sf $DEPLOY_LOG "${{ secrets.DEPLOY_PATH }}/workflow_logs/latest_deploy.log"
      
      - name: ‚úÖ Verify deployment
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          script: |
            cd ${{ secrets.DEPLOY_PATH }}
            
            # Setup variables
            DOMAIN="${{ secrets.VPN_DOMAIN || env.DEFAULT_DOMAIN }}"
            TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
            VERIFY_LOG="${{ secrets.DEPLOY_PATH }}/workflow_logs/verify_${TIMESTAMP}.log"
            
            echo "Verification started at $(date)" > $VERIFY_LOG
            echo "Domain: ${DOMAIN}" >> $VERIFY_LOG
            
            # Wait for container to stabilize
            echo "Waiting for service to stabilize..." >> $VERIFY_LOG
            sleep 30
            
            # Check container status
            echo "Container status:" >> $VERIFY_LOG
            docker-compose ps >> $VERIFY_LOG 2>&1
            
            # Check container health
            CONTAINER_STATUS=$(docker inspect --format='{{.State.Health.Status}}' 3x-ui 2>/dev/null || echo "Container not found")
            echo "Health status: $CONTAINER_STATUS" >> $VERIFY_LOG
            
            # Check services
            echo "Checking service endpoints:" >> $VERIFY_LOG
            curl -s -o /dev/null -w "Admin panel: HTTP %{http_code}\n" http://localhost:54321/login >> $VERIFY_LOG 2>&1 || echo "Failed to connect to admin panel" >> $VERIFY_LOG
            curl -s -o /dev/null -w "HTTPS: %{http_code}\n" -k https://${DOMAIN} >> $VERIFY_LOG 2>&1 || echo "Failed to connect to domain" >> $VERIFY_LOG
            curl -s -o /dev/null -w "VPN panel: %{http_code}\n" -k https://${DOMAIN}:2053/BXv8SI7gBe/ >> $VERIFY_LOG 2>&1 || echo "Failed to connect to VPN panel" >> $VERIFY_LOG
            
            # Log container logs
            echo "Container logs:" >> $VERIFY_LOG
            docker-compose logs --tail=50 >> $VERIFY_LOG 2>&1
            
            echo "Verification completed at $(date)" >> $VERIFY_LOG
            ln -sf $VERIFY_LOG "${{ secrets.DEPLOY_PATH }}/workflow_logs/latest_verify.log"
            
            # Check deployment success
            if [[ "$CONTAINER_STATUS" = "healthy" ]]; then
              echo "‚úÖ Deployment successful! Container is healthy."
              exit 0
            else
              echo "‚ùå Deployment verification failed. Container status: $CONTAINER_STATUS"
              echo "See logs for details: $VERIFY_LOG"
              exit 1
            fi
      
      - name: üì• Download logs
        if: always()
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          source: ${{ secrets.DEPLOY_PATH }}/workflow_logs/latest_*.log
          target: ./workflow_logs
          strip_components: 2
      
      - name: üì¶ Archive logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-logs
          path: ./workflow_logs/
          retention-days: 7 